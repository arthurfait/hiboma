# はじめてのOSコードリーディング

## 2章プロセス

 * u変数
   * レジスタを利用して、プロセス情報に簡易にアクセスできる方法を提供する、のがミソ

## 3章プロセス

### forkシステムコール

 * Cの関数は _ をつけることで アセンブラの中から呼び出しできる
 * unsigned型が無かった
 * PSW[0] (キャリービット) でエラー通知

 * テキストセグメントを共有する
 * 親プロセスのデータセグメントを子プロセスに丸っとコピーする実装である
   * メモリが足らないと swap 待ちになる
     * 親プロセスの実行も xswap(swapout)の間待ちになる
   * 子プロセスが exec する場合 効率が悪い

    malloc(coremap, n)
    /* 略 */
    while(n--)
        copyseg(a1++, a2++);

データセグメントのでかいプロセスをforkした際のコストが非常に高い実装

### 実行プロセスの選択アルゴリズム

> * 実行可能状態である (SRUN)
> * 実行優先度が最も高い (proc.p_prigが小さい
> 特定のプロセスが実行プロセスとなるように、明示的に指定することはできません


## 5章 割り込み・トラップ

 * 割り込み、ポーリング
   * ポーリングでデバイスの状態を見るようなコードはどうなる?
   * フロッピーのドライバがタイマ割り込みでポーリングする仕組みらしい

> デバイスドライバはカーネルの一部であるので、もし、ドライバがポーリングし続ける とすると、システムに悪影響を与える。
> というのも、その場合、デバイスがリクエスト を完了するまで、カーネル内では何も実行されなくなるからである。
> しかし、実際にポーリングを行うデバイスドライバは、システムタイマーを使用して、 一定時間経過後に、
> カーネルにデバイスドライバ内のルーチンを呼び出してもらうよう にしている。
> このシステムタイマーのルーチンは、コマンドのステータスをチェックする。Linux の フロッピードライバは、
> まさにこの仕組みを使っている。だが、タイマーを使った ポーリングでは、精々大ざっぱな制御しかできない。
> もっと効率の良い方法は、 割り込み(interrupt)を使うことである。

 * トラップが発生すると PSW(Processor Status Word)レジスタのビットを立てる
 * sys 命令 TODO:
   * 実際は trap
   * トラップは優先度8
 * `割り込み要求を送り続ける` とは?

