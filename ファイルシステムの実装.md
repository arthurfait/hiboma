# ファイルシステムの実装

### 注意書き

 * 筆者の自習、教育的な用途を目的とした文章です
 * カーネルのバージョンは 2.6.32 ベースで記述しています
 * バニラカーネルのソースを掲載したページへのリンクを貼っているが、CentOSのカーネルはパッチが当たっているので、内容が全然一致しない場合があります
 * backing store を RAM にしたファイルシステムを念頭にしていて、ブロックデバイスのことは考えていません
   * ブロックデバイスベースのファイルシステムは複雑ぽいので、tmpfs と VirtualBox の vboxsf [ソース](https://www.virtualbox.org/wiki/Downloads)を参考に読み解いていく
      * vboxfs のソースは src/VBox/Additions/linux/sharedfolders 以下
   * 追記: tmpfs よりも ramfs の方が素朴な実装なので、最初に読むなら ramfs。ただし、カーネルのAPIをある程度知らないと逆に手がかかりがなさ過ぎるかも
   * 追記: fs/libfs.c の関数群も実装のヒントになる
 * 単語の定義を明確
   * _割り当て_ と書いた場合は、カーネルのメモリ管理APIで実メモリを確保していることを指すようにします (破棄はその逆)
   * _初期化_ と書いた場合は、メモリ割り当てされた構造体の未初期化のフィールドを初期化することを指すようにします
   * _実装_ と書いた場合は、モジュール作成者が任意のコードを書く必要があることを指すようにします
 * [https://github.com/hiboma/nukofs](https://github.com/hiboma/nukofs) に学習用の実装を残しています

## ファイルシステムをカーネルモジュールとして実装する
 
 * Linuxのファイルシステムはカーネルモジュールとして実装できます
   * OSが起動中に動的にロード可能、もしくは削除可能

## モジュールの modules_init で register_filesystem を呼びファイルシステムを登録する
 
独自のファイルシステムをカーネルに登録するには [struct file_system_type](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1745) を定義する

 * カーネルモジュールの modules_init マクロに定義した関数内で [register_filesystem](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L56) で登録したらよい
 * 削除するときは  modules_exits マクロに定義した関数内で [unregister_filesystem](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L90) を呼べばよい
 
register_filesystem は file_system_type の [fs_supers](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1753) リストに繋げるだけで、後述する .get_sb, .kill_sb の super_block の操作は何もしない
 
## struct file_system_type の実装

ファイルシステム名の登録( _/proc/filesystems_ で参照できる ) とsuper_block のコンストラクタ/デストラクタを実装する

 * struct fils_system_type の .get_sb と .kill_sb メンバの実装が必要
   * とはいえ１から全て書く必要は無くて、ひな形として流用できる関数が用意しされているので利用する
 * .get_sb
   * [get_sb_nodev](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L855) をラップすればよい
     * デバイスを持たないファイルシステムで superblock を取得するための関数 [#](http://filesystem.g.hatena.ne.jp/n314/20080325/1206426881)
     * get_sb_nodev の中で [sget](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L338) が superblock *sb のメモリを割り当ててくれる
       * [alloc_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L54) で `kzalloc(sizeof(struct super_block),  GFP_USER);` で割当
    * fill_super 関数ポインタを実装して superblock のメンバを初期化する必要がある
 * kill_sb 
   * [kill_litter_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L703) は [kill_anon_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L689) のラッパーで[d_genocide](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L2176) を使えばよい
     * kill_litter_super は [d_genocide](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L2176) を呼び出す。
       * root dentry から辿って全てのサブディレクトリ以下の dentry の参照カウントをデクリメントする
       * デクリメントするだけで dentry の破棄はしないぽい
     * [kill_anon_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L689) -> [generic_shutdown_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L693) で [shrink_dcache_for_umount](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L302) を呼んで dentry のキャッシュを破棄する

__misc__

 * .get_sb メンバは 2.6.39 まで。それ以降は .mount になる (vboxfsを参照)
   * get_sb_nodev が変わり mount_nodev になる
 * kill_anon_super の ___anon___ は super_block と結びついた block device が無いことを指すのだろう (anonymouse page 的な)

## struct superblock の初期化 fill_super の役割

 * ファイルシステムの superblock と、ファイルシステムの root ディレクトリとなる VFS inode/dentry の割当て、初期化をする必要がある
 * fill_super の型をもつ関数ポインタを実装して get_sb_nodev に渡すことで上記の要件を実装する

なおここでの __inode__ はカーネルのメモリ上で扱われるVFSの `struct inode` のことで、backing store の inode 情報のことではない
backing store の inode 情報を VFSの `struct inode` にマップするのはまた別の話

### vboxsf
 
 * sf_read_super_aux で実装している

### tmpfs
 
 * [shmem_fill_super](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2305) で実装している

### ramfs

 * [ramfs_fill_super](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L216)

#### ramfs は tmpfs と似ているが下記の違いがある

 * [save_mount_options](http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.32#L687) で mount(2)のオプション (void *data) を kstrdup する
    * [generic_show_options](http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.32#L664) を使いたい場合は save_mount_options をあらかじめ呼んで置く必要がある、とコメントがついてる
    * generic_show_options は .show_options のコールバック
 * [ramfs_parse_options](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L184) でマウントオプションのパース。
    * 文字列処理の参考になる
 * 実装のコードはほぼおんなじだけど、__ramfs__ と __rootfs__ と二つのファイルシステムを提供している
   * rootfs の場合は マウントのフラグに MS_NOUSER を足している。ユーザ空間からの mount を許可しない fs なのだった
   * ramfs はユーザ空間から普通にマウントできるやつ

### fill_super の詳細

```
(int *fill_super)(struct super_block *sb, void *data, int silent)
```

`struct super_block *sb` は [get_sb_nodev](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L855) の中で [sget](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L338) -> [alloc_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L54 )で割り当てられたもので、下記の各種メンバが初期化されていない

 * .s_blocksize
   * ブロックサイズ
   * ramfs, tmpfs は PAGE_CACHE_SIZE = PAGE_SIZE で指定されている
   * vboxsf は 1024
 * .s_blocksize_bits
   * ブロックサイズをビット値で表した数値 (つまりブロックサイズは2の倍数である必要がある)
   * ramfs, tmpfs は PAGE_CACHE_SHIFT = PAGE_SHIFT = 12 (4096) で指定されている
   * vboxsf は未定義
 * .s_magic
   * マジックナンバー。他のファイルシステムと競合しない数値を選ぶ必要がある
 * .s_maxbytes
   * 最大ファイルサイズ
   * [MAX_LFS_FILESIZE](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1003)
     * 32bitの場合、ページキャッシュのサイズを上限とする
 * .super_operations
   * vboxfs は sf_super_ops
   * tmpfs は [shmem_ops](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2488)
   * ramfs は [ramfs_ops](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L160)
 * .s_root
   * root になる dentry
   * rootディレクトリの VFS inode を作り、[d_alloc_root](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L1085) で root dentry を割り当てる必要がある
     * tmpfs は [shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541) の [new_inode](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32#L655) から inode を作る
       * [alloc_inode](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32#L212) で `kmem_cache_alloc(inode_cachep, GFP_KERNEL);` することで inode が割り当てされる
       * shmem_get_inode は root dentry 用以外の inode も割り当てできるように汎用的になっている
     * ramfs は [ramfs_get_inode](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L54)
     * vboxsf は`iget_locked(sb, 0)` で 0番の inode を作る
 * ctime, mtime, atime の粒度?
 
全てのメンバを明示的に初期化しなくてもよい様子

__misc__

 * get_sb_nodev 以外にも [get_sb_pseudo](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L207) などある
   * ファイルシステムのバックエンドに応じて呼び出せばよい?

## ファイルシステムの root ディレクトリとなる VFS inode の初期化

 * root ディレクトリの VFS inode を割り当て、パーミッション, uid/gid, 各種operations を初期化する必要がある
 * ブロックデバイスベースのファイルシステムの場合は、デバイスからrootディレクトリのinode情報を読み取って適宜初期化する必要がある
   * ext2_fill_super, ext3_fill_super は sb_bread で super_block のブロックを読み込んでる [refs](http://lxr.free-electrons.com/source/fs/ext2/super.c?v=2.6.32#L785)
   * RAMベースの場合は、ファイルシステムの都合で適当に初期化しておけば良い

### tmpfs

 * [shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541)を見るのがよい

### ramfs

 * ramfsの[ramfs_get_inode](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L54)はもっとシンプル
   * simple_dir_operations とは?
   * [mapping_set_gfp_mask](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L64) とは?
     * `mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);`
     * address_space の メモリ割り当てを Highメモリから取る? High メモリ is なに?
     * refs http://seijinoblog.blogspot.jp/2012/03/linux_29.html
   * [mapping_set_unevictable](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L38) とは?
     * [Unevictable LRU](https://www.kernel.org/doc/Documentation/vm/unevictable-lru.txt) を読んで理解する
     * アドレス空間全体を AS_UNEVICTABLE としてフラグをセット
     * ramfs の inode ページフレームがが回収されちゃったら困るから、 AS_UNEVICTABLE とするのだろう?

```
Unevictable リストとは文字どおり、強制回収できないリストを表す。この機構は比較的最近実装された
もので、64 bit 環境で 100GB を越える大容量な RAM を搭載した環境におけるページフレーム回収コス
トを減らす目的で導入されている。最新のカーネルドキュメント (*2) によれば、unevictable リストに
属するページは、次の 3 種類のページになる (らしい)。

　・ramfs が所有するページ
　・共有メモリロックのメモリリージョンにマッピングされているページ
　・VM_LOCKED フラグがセットされたメモリリージョンにマッピングされているページ
```

[lkml でお勉強 (その1-2)](http://dev.ariel-networks.com/Members/ohyama/lkml-304a52c95f37-305d306e1-2/)
 
### [struct inode](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L723) 各種メンバ

struct indoe = VFS inode
 
 * i_mode 
    * パーミッションはファイルシステムのポリシーで任意
    * i_mode に S_IFDIR 足しとかないと mount(2) で ENOTDIR `Not a directory` 返すので注意
 * uid,gid
 * atime, mtime, ctime
    * CURRENT_TIMEマクロを使うと現在時刻で初期化できる
 * i_mapping->backing_dev_info 
 * i_mapping->a_ops
 * inode_operations
    * ファイルとディレクトリとで実装内容が違う
 * ファイルの場合は
   * file_operations
 * ディレクトリの場合は
   * dir_operations
 * nlink リンク数
 * ブロック数
   * backing store が RAM の場合、適当な数値を入れてハックする必要があるぽい (tmpfsの例)

__misc__

 * vboxsf はホストOSの共有フォルダの情報を sf_stat で調べて情報を取り、sf_init_inode で適宜埋める様子
   * ホストOSはUNIX系OSとは限らないので汎用的な作りになってる
 * tmpfs の場合 [shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541) で初期化している   
 * その他 dquot_operations, quotactl_ops, export_operations (nfs) は必要なら適宜初期化したらよい様子
 * tmpfs では俺俺の [struct shmem_sb_info](http://lxr.free-electrons.com/source/include/linux/shmem_fs.h?v=2.6.32#L24) を sb->s_fs_info に入れている
   * s_fs_info は `void * s_fs_info /* Filesystem private info */` とあり、ファイルシステム固有の俺俺データを入れとく用途
   * tmpfsでは各種制限が設けられていて、その閾値をぶっ込んでいる
    * [shmem_default_max_blocks](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L110) で ブロックの最大数を [totalram_pages](http://wiki.bit-hive.com/north/pg/%A5%C8%A1%BC%A5%BF%A5%EB%A5%E1%A5%E2%A5%EA)/2 としている
    * [shmem_default_max_inodes](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L115) で inodeの最大数を min(totalram_pages - totalhigh_pages, totalram_pages / 2); にしている
 * tmpfs として利用する場合は MS_NOUSERフラグが落ちてる
 
## struct backing_dev_info とは?

* アドレス空間の背後にある周辺機器(peripheral device)を __Backing store__ と呼ぶ (refs Linux Kernel Architecture p.957 )
* ふつーはブロックデバイスだけど、もちろんRAMベースもある。

backing store のメタデータを入れておくのが [struct backing_dev_info](http://lxr.free-electrons.com/source/include/linux/backing-dev.h?v=2.6.32#L60)

 * [bdi_init](http://lxr.free-electrons.com/source/mm/backing-dev.c?v=2.6.32#L651 ) で登録
 * [bdi_destroy](http://lxr.free-electrons.com/source/mm/backing-dev.c?v=2.6.32#L693) で解除

### struct backing_dev_info のメンバ

 * ra_pages 
   * 先読みするページの最大数を指定(readahead pages)
   * RAMだと先読みいらんし、ブロックデバイスだけで有効かな
 * capabilities 
   * ページを backing store と同期(write back)する際のポリシーなどを指定
   * ブロックデバイスだと必要だけど RAM だといらん 
   * mmap できるかなども指定するぽい   
   * [各種フラグ](http://lxr.free-electrons.com/source/include/linux/backing-dev.h?v=2.6.32#L200)
     * BDI_CAP_NO_ACCT_AND_WRITEBACK
     * BDI_CAP_NO_ACCT_DIRTY RAM backing store だとページが dirty かどうかの判定いらん
       * これらのフラグがどうやって利用されてるかが謎。
 * dev 
   * struct device 入れておく。 RAM backing store だと null 入れておkらしい
   
他にもいろいろ面白そうなメンバあるけど、ブロックデバイスじゃないと関係なさそうな空気   
   
## [struct super_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1562) の実装

RAMベースだと全てを実装する必要は無い。

### vboxsfの実装

2.6.32用のvboxsfで実装されるメンバは下記の4つ

 * .clear_inode
   * inode->private から sf_inode_info を取り出して kfree
 * .put_user 
   * umount(2) して super_blockを解放する時に呼ぶ?
   * super_block から sf_glob_info を取り出して、backing_dev を bdi_destroy してる
   * vboxCallUnmapFolder でホストOSのフォルダとのマップを解除
 * .remount_fs
 * .statfs

vboxsfでは実データのinodeはホストOSのファイルシステムが見てるので、特にCRUDな操作を必要としない様子。vboxsfがゲストOSとホストOSの間を透過的にするレイヤになる

#### .statfs

```c
// mountポイントの dentry
// STRUCT_STATFS は struct kstatfs で、ユーザランドに渡したい数値でフィールドを初期化すればよい
static int sf_statfs(struct dentry *dentry, STRUCT_STATFS *stat)
{
    struct super_block *sb = dentry->d_inode->i_sb;
    return sf_get_volume_info(sb, stat);
}

// ...

// ホストOSに statfs を投げてるのかな?
// /vagrant のdf は sharedしているホストOSのファイルシステムのdf と一致する
int sf_get_volume_info(struct super_block *sb, STRUCT_STATFS *stat)
{
    struct sf_glob_info *sf_g;
    SHFLVOLINFO SHFLVolumeInfo;
    uint32_t cbBuffer;
    int rc;

    sf_g = GET_GLOB_INFO(sb);
    cbBuffer = sizeof(SHFLVolumeInfo);
    rc = vboxCallFSInfo(&client_handle, &sf_g->map, 0, SHFL_INFO_GET | SHFL_INFO_VOLUME,
                        &cbBuffer, (PSHFLDIRINFO)&SHFLVolumeInfo);
    // Runtime
    // ホストOSからで発生したエラー -> VirtualBoxのエラー -> ゲストOSのエラーに変換
    if (RT_FAILURE(rc))
        return -RTErrConvertToErrno(rc);

    stat->f_type        = NFS_SUPER_MAGIC; /* XXX vboxsf type? */
    stat->f_bsize       = SHFLVolumeInfo.ulBytesPerAllocationUnit;
    stat->f_blocks      = SHFLVolumeInfo.ullTotalAllocationBytes
                        / SHFLVolumeInfo.ulBytesPerAllocationUnit;
    stat->f_bfree       = SHFLVolumeInfo.ullAvailableAllocationBytes
                        / SHFLVolumeInfo.ulBytesPerAllocationUnit;
    stat->f_bavail      = SHFLVolumeInfo.ullAvailableAllocationBytes
                        / SHFLVolumeInfo.ulBytesPerAllocationUnit;
    stat->f_files       = 1000;
    stat->f_ffree       = 1000; /* don't return 0 here since the guest may think
                                 * that it is not possible to create any more files */
    stat->f_fsid.val[0] = 0;
    stat->f_fsid.val[1] = 0;
    stat->f_namelen     = 255;
    return 0;
}
```

 * df -i で 空き inode の数が 1000 と出るけど、これはハードコードされてる数値で意味はない

```
[vagrant@cent6-build-php ~]$ df -i /vagrant/
Filesystem     Inodes IUsed IFree IUse% Mounted on
/vagrant         1000     0  1000    0% /vagrant
```

### tmpfsの実装

tmpfs の [shmem_ops](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2488) で実装されているメンバは下記の通り 

 * [.alloc_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2377), .destroy_inode
   * kmem_cache_alloc, kmem_cache_free で shmem_inode_info のメモリを割当/解放
      * shmem_inode_info の .vfs_inode メンバを `struct inode` として返す
   * RAMベースの場合、自前でメモリ抱えて inode を返さないといけないのかな?
 * [.statfs](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1780)
   * statfs(2) のデータを `struct kstatfs` に埋めて返す
   * ブロックサイズ、空き/使用済みブロック、空き/使用済みinode数 などを入れる 
 * [.remount_fs](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2237)
   * remount の際に呼ばれてそう。マウントオプションのパースは自分で頑張る必要がある
 * [.show_options](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2279)
   * ファイルシステム固有のオプションを表示する、とのこと
   * seq_printf で任意の文字列をユーザランドに渡せる
 * .delete_inode 
   * ___メモリ上にあるVFSのinodeとディスク上のデータ、メタデータを削除します___
     * truncate?の場合は inode についた pages を truncate_inode_pages でページキャッシュから解放している
     * shmem_free_inode で 空きinode数をインクリメント
     * その後 clear_inode する。 super_operations の s_op が定義されていれば 呼び出す様子
 * .drop_inode
 * [.put_user](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2299)
   * sb->s_fs_info を kfree してるだけ。任意の操作を入れといたらいいのかな?

### ramfs

 * .statfs は simple_statfs

### df で Function not implemented [#13](https://github.com/hiboma/nukofs/issues/13)

```
[vagrant@vagrant-centos65 vagrant]$ df -h
df: `/mnt/nukofs': Function not implemented
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       7.3G  1.3G  5.7G  19% /
tmpfs           295M     0  295M   0% /dev/shm
/vagrant        931G  273G  658G  30% /vagrant
```

 * .statfs を simple_statfs にしとくと Function ... は出なくなるけど、容量の数値は出ない

```
# $ strace df
statfs("/mnt/nukofs", {f_type=0xca10, f_bsize=4096, f_blocks=0, f_bfree=0, f_bavail=0, f_files=0, f_ffree=0, f_fsid={0, 0}, f_namelen=255, f_frsize=4096}) = 0
```

 * f_blocks, f_bfree, f_bavail, ... が 0 だと、 何もオプションつけない df じゃ出力されん
   * df -a で確認できる

```sh
#       -a, --all
#              include dummy file systems
$ df -a
[vagrant@vagrant-centos65 vagrant]$ df -a
Filesystem     1K-blocks      Used Available Use% Mounted on
/dev/sda1        7635048   1353516   5893692  19% /
proc                   0         0         0    - /proc
sysfs                  0         0         0    - /sys
devpts                 0         0         0    - /dev/pts
tmpfs             301788         0    301788   0% /dev/shm
none                   0         0         0    - /proc/sys/fs/binfmt_misc
/vagrant       975922976 286194092 689728884  30% /vagrant
nukofs                 0         0         0    - /mnt/nukofs
```

 * .shmem_statfs のように `struct kstatfs` に何かしら数値いれとくと空き容量や空きブロックをユーザランドに返せる
   * 当たり前だけど、これらの数値はファイルシステムの実装で加減して管理しとくもの

```c
static int shmem_statfs(struct dentry *dentry, struct kstatfs *buf)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(dentry->d_sb);

	buf->f_type = TMPFS_MAGIC;
	buf->f_bsize = PAGE_CACHE_SIZE;
	buf->f_namelen = NAME_MAX;
	if (sbinfo->max_blocks) {
		buf->f_blocks = sbinfo->max_blocks;
		buf->f_bavail =
		buf->f_bfree  = sbinfo->max_blocks -
				percpu_counter_sum(&sbinfo->used_blocks);
	}
	if (sbinfo->max_inodes) {
		buf->f_files = sbinfo->max_inodes;
		buf->f_ffree = sbinfo->free_inodes;
	}
	/* else leave those fields 0 like simple_statfs */
	return 0;
}
```

__memo__

 * backing store が ブロックデバイスでなければ .dirty_inode, .write_inode, .write_super, は実装しなくてよい
    * メモリ上のデータがdirtyでもブロックデバイスのデータと同期する必要がないから
 * 2.6.25 未満では .read_inode の実装が必要

## register_file_system したら次はマウントする

ファイルシステムを登録したら vfs_kern_mount でマウントできる

```
struct vfsmount vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
```

vfs_kern_mount はカーネル内でマウントするAPIで、ユーザランドから mount(2) してもよい。


 * MS_NOUSER フラグ
   * カーネル内部でマウントするものでユーザランドからマウントするもんじゃないことを指定 [#](http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/2024.html)
   * MS_NOUSER をつけておいて、vfs_kern_mount でカーネルモジュール内でマウントするファイルシステムがある (pipefs?)
     * Pseudo-Filesystems の項を参照
 * magic
 * ブロックサイズ
 * super_ops
 * root ディレクトリの初期化
  * dentry
  * inode

## [struct inode_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1518) の実装

nukofs を mount したディレクトリに通常ファイルを作成したいので inode_operations の必要なメンバを実装する

### .lookup

```c
/**
 * This is called when vfs failed to locate dentry in the cache. The
 * job of this function is to allocate inode and link it to dentry.
 * [dentry] contains the name to be looked in the [parent] directory.
 * Failure to locate the name is not a "hard" error, in this case NULL
 * inode is added to [dentry] and vfs should proceed trying to create
 * the entry via other means. NULL(or "positive" pointer) ought to be
 * returned in case of success and "negative" pointer on error
 */
static struct dentry *sf_lookup(struct inode *parent, struct dentry *dentry
```

 * vboxsf の説明には sf_lookup VFS が dentry を cache miss した際に呼ばれる。inode を割り当て、dentry と link する
 * [simple_lookup](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L47) が用意されているので使える

```
ディレクトリ .dir を検索します。dエントリオブジェクト dentry に含まれるファイル名に対応するinodeを見つけるためです
```

### VFS inode の割り当て

 * tmpfs の [shmem_mknod](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1805), [ramfs](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L95) の ramfs_mknod ともにファイル/ディレクトリ作成に .mknod のコールバックを流用している
   * .mknod は [mknod(2)](http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.32#L2094) で呼び出されるコールバック
     * vfs の呼び出しを見ると、通常ファイルでは vfs_create, その他では vfs_mknod を呼び出している
     * 通常ファイルを作るには .create を実装しておかないといけないのね
   * VFS inode は 汎用API ( shmem_get_inode, ramfs_get_inode ) で割り当てている
   * VFS inode を [d_instantiate](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L991) と [dget](http://lxr.free-electrons.com/source/include/linux/dcache.h?v=2.6.32#L320) している
     * d_instantiate は VFS inode のデータで dentry を初期化? する
     * dget は参照カウントをインクリメントする = dentry cache との関係?

 * コンストラクタ的なコールバックは自前で実装が必要ぽいけど、デストラクタっぽいのは simple_*** みたいなので事足りるのかな?
   * fs/libfs.c に `Library for filesystems writers` とコメント有るので、ファルシステム作成を支援するライブラリぽい

### .create

 * .create
   * .create は `dentry に対応する通常ファイル用に、新しいディスクinodeを作成します`

### umount(2) をする際に Oops! した [#4](https://github.com/hiboma/nukofs/issues/4)

.create, .mknod を実装して、通常ファイルを作成して umount したら oops

![](https://f.cloud.github.com/assets/172456/1930814/a19ef548-7eb4-11e3-8346-525a55b40c00.png)

 * umount すると [shrink_dcache_for_umount](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L715) で superblock にぶら下がった dentry を破棄する
 * [shrink_dcache_for_umount_subtree](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L619)
   * .kill_sb を kill_anon_super から kill_litter_super にしたら解決した
     * vboxsf は kill_anon_super だな
   * umount する前に dentry を掃除しておかないとだめぽい
     * `atomic_read(&dentry->d_count) != 0` を満たさないと BUG() を出す [refs](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L658)

### unlink(2) が Operation not permitted [#6](https://github.com/hiboma/nukofs/issues/6)

下記の通り、[vfs_unlink](http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.32#L2277) で i_op->unlink が NULL だと -EPERM を返す

```c
int vfs_unlink(struct inode *dir, struct dentry *dentry)
{
	int error = may_delete(dir, dentry, 0);

	if (error)
		return error;

	if (!dir->i_op->unlink)
		return -EPERM;
```

 * ディレクトリの inode_operations に `.unlink = simple_unlink` を実装して解決した
    * ramfs は [simple_unlink](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L287)
      * drop_nlink と dput が肝
      * ハードリンクされている場合は unlink(2) しても inode は残るので `inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;` している
        * ディレクトリの c_time, mtime が更新されてるのがポイント
    * tmpfs は [shmem_unlink](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1881)
       * [shmem_free_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L258) で superblock の空きinode数をインクリメントしているのが simple_unlink と違う
       * `sbinfo->free_inodes` は tmpfs の inode数上限を管理するための数値
    * vbosf は sf_unlink -> sf_unlink_aux でホストOSとやり取り。
      * ホストOS のinodeとゲストの VFS inode, dentry がどう扱われてるかを覗ける

__misc__

 * ramfs_mknod のコメントに `/* SMP-safe */` とある
 * VFSでは SMP のことは何も考えなくていいのかな

### mkdir(2) が Operation not permitted [#8](https://github.com/hiboma/nukofs/issues/8)

.mkdir, .rmdir を実装する必要がある

 * .mkdir は自前で頑張る。
 * .rmdir は [simple_rmdir](http://lxr.free-electrons.com/ident?v=2.6.32&i=simple_rmdir) で代用できた
   * rmdir -> do_rmdir -> vfs_rmdir -> .rmdir
   * `int vfs_rmdir(struct inode *dir, struct dentry *dentry)` *dir は親ディレクトリかな。dentry は rmdir したいディレクトリのdentry
     * `d_mountpoint(dentry)` で マウントされているかいなかを見る
   * simple_rmdir は [simple_unlink](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L287) 呼び出している
   * 通常ファイルと同じように unlink するけど、親ディレクトリの inode->i_nlink(リンク数) を drop_nlink デクリメントするのが違う
   

### vfs_rename

```c
int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
	       struct inode *new_dir, struct dentry *new_dentry)
{
	int error;
	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
	const char *old_name;

    // rename する対象が一緒なら何もしない
	if (old_dentry->d_inode == new_dentry->d_inode)
 		return 0;

    // 複雑
	error = may_delete(old_dir, old_dentry, is_dir);
	if (error)
		return error;

	if (!new_dentry->d_inode)
		error = may_create(new_dir, new_dentry);
	else
		error = may_delete(new_dir, new_dentry, is_dir);
	if (error)
		return error;

    // rename 元のディレクトリが .rename を実装していなければ -EPERM
	if (!old_dir->i_op->rename)
		return -EPERM;

	vfs_dq_init(old_dir);
	vfs_dq_init(new_dir);

	old_name = fsnotify_oldname_init(old_dentry->d_name.name);

	if (is_dir)
		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
	else
		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
	if (!error) {
		const char *new_name = old_dentry->d_name.name;
		fsnotify_move(old_dir, new_dir, old_name, new_name, is_dir,
			      new_dentry->d_inode, old_dentry);
	}
	fsnotify_oldname_free(old_name);

	return error;
}
```

```c
/*
 * The worst of all namespace operations - renaming directory. "Perverted"
 * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
 * Problems:
 *	a) we can get into loop creation. Check is done in is_subdir().
 *	b) race potential - two innocent renames can create a loop together.
 *	   That's where 4.4 screws up. Current fix: serialization on
 *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
 *	   story.
 *	c) we have to lock _three_ objects - parents and victim (if it exists).
 *	   And that - after we got ->i_mutex on parents (until then we don't know
 *	   whether the target exists).  Solution: try to be smart with locking
 *	   order for inodes.  We rely on the fact that tree topology may change
 *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
 *	   move will be locked.  Thus we can rank directories by the tree
 *	   (ancestors first) and rank all non-directories after them.
 *	   That works since everybody except rename does "lock parent, lookup,
 *	   lock child" and rename is under ->s_vfs_rename_mutex.
 *	   HOWEVER, it relies on the assumption that any object with ->lookup()
 *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
 *	   we'd better make sure that there's no link(2) for them.
 *	d) some filesystems don't support opened-but-unlinked directories,
 *	   either because of layout or because they are not ready to deal with
 *	   all cases correctly. The latter will be fixed (taking this sort of
 *	   stuff into VFS), but the former is not going away. Solution: the same
 *	   trick as in rmdir().
 *	e) conversion from fhandle to dentry may come in the wrong moment - when
 *	   we are removing the target. Solution: we will have to grab ->i_mutex
 *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
 *	   ->i_mutex on parents, which works but leads to some truely excessive
 *	   locking].
 */
static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
			  struct inode *new_dir, struct dentry *new_dentry)
{
	int error = 0;
	struct inode *target;

	/*
	 * If we are going to change the parent - check write permissions,
	 * we'll need to flip '..'.
	 */
	if (new_dir != old_dir) {
		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
		if (error)
			return error;
	}

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
	if (error)
		return error;

	target = new_dentry->d_inode;
	if (target) {
		mutex_lock(&target->i_mutex);
		dentry_unhash(new_dentry);
	}
    
    // マウントポイントは rename できない
	if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
		error = -EBUSY;
	else 
		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
	if (target) {
		if (!error)
			target->i_flags |= S_DEAD;
		mutex_unlock(&target->i_mutex);
		if (d_unhashed(new_dentry))
			d_rehash(new_dentry);
		dput(new_dentry);
	}
	if (!error)
		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
			d_move(old_dentry,new_dentry);
	return error;
}

static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
			    struct inode *new_dir, struct dentry *new_dentry)
{
	struct inode *target;
	int error;

	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
	if (error)
		return error;

	dget(new_dentry);
	target = new_dentry->d_inode;
	if (target)
		mutex_lock(&target->i_mutex);
	if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
		error = -EBUSY;
	else
		error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
	if (!error) {
		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
			d_move(old_dentry, new_dentry);
	}
	if (target)
		mutex_unlock(&target->i_mutex);
	dput(new_dentry);
	return error;
}
```

 * 削除したけど開きっぱなしのでディレクトリは S_DEAD 状態らしい
   * `#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)`
   * `#define S_DEAD		16	/* removed, but still open directory */`

#### tmpfs

simple_unlink を呼ぶ順番が前後してるだけで、 simple_rmdir とほぼ同じ

 * [shmem_rmdir](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1895)
   * [simple_empty](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L272) でディレクトリが空かどうか(dentryのサブディレクトリを走査) みる
   * [shmem_unlink](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1881) をラップしている

### rename(2) が 'Operation not permitted' #17

 * .rename を実装する必要がある
   * ディレクトリとファイルの可能性がある indoe をどう扱うか?

#### tmpfs

 * [shmem_rename](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1911) で実装
   * simple_rename とほぼ同じ実装だが、 shmem_unlink を呼び出す違い
   * i_size に BOGO_DIRENT_SIZE を加減している
     * BOGO_DIRENT_SIZE はアテでいれてるディレクトリのサイズぽい。
     * ramfs ではそのようなことをしないので、ディレクトリのサイズが 0 になる

```c
/*
 * The VFS layer already does all the dentry stuff for rename,
 * we just have to decrement the usage count for the target if
 * it exists so that the VFS layer correctly free's it when it
 * gets overwritten.
 */
static int shmem_rename(struct inode *old_dir, struct dentry *old_dentry,
                        struct inode *new_dir, struct dentry *new_dentry)
{
	struct inode *inode = old_dentry->d_inode;
	int they_are_dirs = S_ISDIR(inode->i_mode);

	if (!simple_empty(new_dentry))
		return -ENOTEMPTY;

	if (new_dentry->d_inode) {
		(void) shmem_unlink(new_dir, new_dentry);
		if (they_are_dirs)
			drop_nlink(old_dir);
	} else if (they_are_dirs) {
		drop_nlink(old_dir);
		inc_nlink(new_dir);
	}

	old_dir->i_size -= BOGO_DIRENT_SIZE;
	new_dir->i_size += BOGO_DIRENT_SIZE;
	old_dir->i_ctime = old_dir->i_mtime =
	new_dir->i_ctime = new_dir->i_mtime =
	inode->i_ctime = CURRENT_TIME;
	return 0;
}
```

#### ramfs

 * [simple_rename](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L308) で実装
   * [simple_empty](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L272) でディレクトリが空かどうかの判定
     * dentry->d_subdirs を見ている。dentry はメモリ上に存在するのでスピンロックかけるだけで高速に判定できるぽい
 * rename(2) 先の dentry が存在するなら unlink(2) しとく
   * sipmle_unlink を使い回しているのが面白い
 * dentry を移動させるので、 drop_nlink と inc_nlink が肝
 * ctime, mtime を更新して終わり

```c
int simple_rename(struct inode *old_dir, struct dentry *old_dentry,
		struct inode *new_dir, struct dentry *new_dentry)
{
	struct inode *inode = old_dentry->d_inode;
	int they_are_dirs = S_ISDIR(old_dentry->d_inode->i_mode);

    // why ?
	if (!simple_empty(new_dentry))
		return -ENOTEMPTY;

    // rename先にファイルが存在している場合は上書きする
	if (new_dentry->d_inode) {
		simple_unlink(new_dir, new_dentry);
		if (they_are_dirs)
			drop_nlink(old_dir);
	} else if (they_are_dirs) {
        // 古いディレクトリのリンクを減らす
		drop_nlink(old_dir);
		inc_nlink(new_dir);
	}

	old_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =
		new_dir->i_mtime = inode->i_ctime = CURRENT_TIME;

	return 0;
}
```

#### vboxsf

 * ホストOSに面倒みてもらわないといけない

```c
/**
 * Rename a regular file / directory.
 *
 * @param old_parent    inode of the old parent directory
 * @param old_dentry    old directory cache entry
 * @param new_parent    inode of the new parent directory
 * @param new_dentry    new directory cache entry
 * @returns 0 on success, Linux error code otherwise
 */
static int sf_rename(struct inode *old_parent, struct dentry *old_dentry,
                     struct inode *new_parent, struct dentry *new_dentry)
{
    int err = 0, rc = VINF_SUCCESS;
    struct sf_glob_info *sf_g = GET_GLOB_INFO(old_parent->i_sb);

    TRACE();

    if (sf_g != GET_GLOB_INFO(new_parent->i_sb))
    {
        LogFunc(("rename with different roots\n"));
        err = -EINVAL;
    }
    else
    {
        struct sf_inode_info *sf_old_i = GET_INODE_INFO(old_parent);
        struct sf_inode_info *sf_new_i = GET_INODE_INFO(new_parent);
        /* As we save the relative path inside the inode structure, we need to change
           this if the rename is successful. */
        struct sf_inode_info *sf_file_i = GET_INODE_INFO(old_dentry->d_inode);
        SHFLSTRING *old_path;
        SHFLSTRING *new_path;

        BUG_ON(!sf_old_i);
        BUG_ON(!sf_new_i);
        BUG_ON(!sf_file_i);

        old_path = sf_file_i->path;
        err = sf_path_from_dentry(__func__, sf_g, sf_new_i,
                                  new_dentry, &new_path);
        if (err)
            LogFunc(("failed to create new path\n"));
        else
        {
            int fDir = ((old_dentry->d_inode->i_mode & S_IFDIR) != 0);

            // ホストOS で rename するよ
            // Windows だとなんだっけ ...
            rc = vboxCallRename(&client_handle, &sf_g->map, old_path,
                                new_path, fDir ? 0 : SHFL_RENAME_FILE | SHFL_RENAME_REPLACE_IF_EXISTS);
            if (RT_SUCCESS(rc))
            {
                // inode の drop_nlink, inc_nlink が無いな
                // ホストOSから取るからいらんのかな?
                kfree(old_path);
                sf_new_i->force_restat = 1;
                sf_old_i->force_restat = 1; /* XXX: needed? */
                /* Set the new relative path in the inode. */
                sf_file_i->path = new_path;
            }
            else
            {
                LogFunc(("vboxCallRename failed rc=%Rrc\n", rc));
                err = -RTErrConvertToErrno(rc);
                kfree(new_path);
            }
        }
    }
    return err;
}
```

#### chown(2) の実装

特に何も実装していないのに chown(2) が成功した why?

 * VFS inode のメンバを変更するだけなら特になんもいらん?
 * chown -> sys_fchownat -> chown_common -> notify_change -> [inode_setattr](http://lxr.free-electrons.com/source/fs/attr.c?v=2.6.32#L108) ( -> generic_setattr)
   * バニラカーネルだと inode_setattr, CentOS6カーネルだと generic_setattr で VFS inode のメンバを変更している
 * dirty な inode をブロックデバイスに書き出すのはまた別 -> super_operations の .dirty_inode かな?
 * chown は sys_fchownat をラップしている

RAMベースのファイルシステムの場合は VFS inode だけを扱えばいいので、特に実装がいらんてことになる

### link(2) が Operation not permitted [#15](https://github.com/hiboma/nukofs/issues/15)

 * vfs_link で -EPERM を返す。.link を実装する必要がある
 * ディレクトリの inode_operations の .link であることに注意 (ファイルではない)

```
int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
{
	struct inode *inode = old_dentry->d_inode;
	int error;

	if (!inode)
		return -ENOENT;

	error = may_create(dir, new_dentry);
	if (error)
		return error;

	if (dir->i_sb != inode->i_sb)
		return -EXDEV;

	/*
	 * A link to an append-only or immutable file cannot be created.
	 */
	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
		return -EPERM;
	if (!dir->i_op->link)
		return -EPERM;
```

### sys_link

 * マウントポイントが違う場合は EXDEV
   * `struct path` の比較

```c
/**
 * lookup_create - lookup a dentry, creating it if it doesn't exist
 * @nd: nameidata info
 * @is_dir: directory flag
 *
 * Simple function to lookup and return a dentry and create it
 * if it doesn't exist.  Is SMP-safe.
 *
 * Returns with nd->path.dentry->d_inode->i_mutex locked.
 */
struct dentry *lookup_create(struct nameidata *nd, int is_dir)
```

``` c
	error = -EXDEV;
	if (old_path.mnt != nd.path.mnt)
		goto out_release;
```

```c
	mutex_lock(&inode->i_mutex);
	vfs_dq_init(dir);
	/* Make sure we don't allow creating hardlink to an unlinked file */
	if (inode->i_nlink == 0)
		error =  -ENOENT;
	else
		error = dir->i_op->link(old_dentry, dir, new_dentry);
	mutex_unlock(&inode->i_mutex);
```

### ramfs

 * [simple_link](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L255)
   * link元になるファイルの inode の nlink と i_count を増やす
   * link元になるファイルの inode から dentry を d_instantiate
     * 複数の dentry が 一個の inode を参照する => hardlink の仕組み
 * i_nlink は ++ だけど、 i_count は atomic_inc なのだな。うーん

```c
int simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = old_dentry->d_inode;

	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
	inc_nlink(inode);
	atomic_inc(&inode->i_count);
	dget(dentry);
	d_instantiate(dentry, inode);
	return 0;
}
```

#### tmpfs

 * [shmem_link](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1857)
   * [shmem_reserve_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L243)
     * free_inodes をデクリメントして inode数を管理
   * ふつーのディスクベースのファイルシステムでは link を inode としてカウントしない (inode 一個だし)
   * tmpfs の link は dentry 割り当て必要 +  lowmem に貼付けておく + tmpfs の dentry は unlink されるまで削除できない

```c
/*
 * Link a file..
 */
static int shmem_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = old_dentry->d_inode;
	int ret;

	/*
	 * No ordinary (disk based) filesystem counts links as inodes;
	 * but each new link needs a new dentry, pinning lowmem, and
	 * tmpfs dentries cannot be pruned until they are unlinked.
	 */
	ret = shmem_reserve_inode(inode->i_sb);
	if (ret)
		goto out;

	dir->i_size += BOGO_DIRENT_SIZE;
	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
	inc_nlink(inode);
	atomic_inc(&inode->i_count);	/* New dentry reference */
	dget(dentry);		/* Extra pinning count for the created dentry */
	d_instantiate(dentry, inode);
out:
	return ret;
}
``` 

## [struct file_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1489) の実装

```
ファイルの読み取りや下記k未などの操作を行う、ファイルシステムごとに固有のファイル操作(file operation)関数群があります
```

 * inode->i_fop メンバ
 * open(2) ないと呼べないよね? ( `struct file` を確保しているのが前提)

### write(2) が Invalid argument [#11](https://github.com/hiboma/nukofs/issues/11)

 * [sys_write](http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.32#L389) -> [vfs_write](http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.32#L332)
   * 以下の通り、file_operations の .write または aio_write を実装しておかないと EINVAL を返す

```c
ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
	ssize_t ret;

	if (!(file->f_mode & FMODE_WRITE))
		return -EBADF;
	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
		return -EINVAL;
	if (unlikely(!access_ok(VERIFY_READ, buf, count)))
		return -EFAULT;

	ret = rw_verify_area(WRITE, file, pos, count);
	if (ret >= 0) {
		count = ret;
		if (file->f_op->write)
			ret = file->f_op->write(file, buf, count, pos);
		else
			ret = do_sync_write(file, buf, count, pos);
		if (ret > 0) {
			fsnotify_modify(file->f_path.dentry);
			add_wchar(current, ret);
		}
		inc_syscw(current);
	}

	return ret;
}
```

`struct file_operations` の .write, .aio_write を実装しよう ↓

#### .write と .aio_write だけ初期化してみたところ panic

![](https://f.cloud.github.com/assets/172456/1949504/47a3daf4-810c-11e3-934c-21473ef89139.png)

 * `struct address_space_operations` の実装も必要だった様子
   * generic_file_aio_write がページキャッシュにデータを載せるため
      * O_DIRECT を指定した際に呼ばれる generic_file_direct_write と比較するとページキャッシュの差が分かりやすい?
      * generic_file_buffered_write の有無 によって差がでる
   * .write_begin, .write_end が必要
     * [simple_write_begin](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L353), [simple_write_end](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L391) が用意されている
     * simple_write_begin は strct *page を割り当て、[simple_prepare_write](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L341) で page の中身をゼロクリア
       * ここでの page は PG_locked
   * .write_page はいらんみたい => ???

#### ramfs, tmpfs

 * [do_sync_write](http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=2.6.32#L40) を使ってる
   * do_sync_write は file_->f_op->aio_write を呼び出してる。 結局 .aio_write が必要なのかn
   * `const char __user *buf` は `struct iovec iov` にまとめられる
 * [generic_file_aio_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2464)
   * `mutex_lock(&inode->i_mutex)` -> inode 単位で直列化
   * [__generic_file_aio_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2334)
     * `current->backing_dev_info = mapping->backing_dev_info`
     * [generic_file_buffered_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2304)
       * [generic_perform_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2212)
       * address_space_operations の .write_begin , .write_end が呼ばれる => 後述

aio は [POSIX AIO](http://linuxjm.sourceforge.jp/html/LDP_man-pages/man7/aio.7.html) とは違う(よね)

## [struct address_space_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L570) の実装

struct file_operations と一緒に実装する必要あり

### ramfs

```c
const struct address_space_operations ramfs_aops = {
	.readpage	= simple_readpage,
	.write_begin	= simple_write_begin,
	.write_end	= simple_write_end,
	.set_page_dirty = __set_page_dirty_no_writeback,
};
```

### tmpfs

```c
static const struct address_space_operations shmem_aops = {
	.writepage	= shmem_writepage,
	.set_page_dirty	= __set_page_dirty_no_writeback,
#ifdef CONFIG_TMPFS
	.write_begin	= shmem_write_begin,
	.write_end	= shmem_write_end,
#endif
	.migratepage	= migrate_page,
	.error_remove_page = generic_error_remove_page,
};
```

### vfs_write から address_space_operations に下るところを追う

[generic_perform_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2212) is 複雑 !!!

 * .write_begin 
   * [simple_write_begin](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L353)
     * [grab_cache_page_write_begin](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2184)
       * find_lock_page で アドレス空間から指定したインデックスを持つ struct *page を返す。page は PG_locked
         * ロックを取れない場合は TASK_UNINTERRUPTIBLE でブロック
         * struct *page は ページフレーム に対応 => 同じページフレームに複数のタスク(割り込みコンテキストは?)から同時書き込みできない
       * [__page_cache_alloc](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L483)
         * struct *page を割り当て
           * NUMAに対応するためにどのメモリノードからページを取るか allow_pages_excat_node で指定
         * alloc_pages 以下は複雑なので別件で追う
       * [add_to_page_cache_lru](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L457)
         * mapping_cap_swap_backed(struct address_space) で address_space が swap 可能かどうかを見ている
           * backing_dev_info の capabilities に BDI_CAP_SWAP_BACKED が立っているか否か
           * tmpfs の場合 true
             * SetPageSwapBacked(page) ???
         * [add_to_page_cache](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L443) ???
         * lru_cache_add_file => LRU_INACTIVE_FILE リストに繋ぐ
         * lru_cache_add_anon => LRU_INACTIVE_ANON リストに繋ぐ
   * [simple_prepare_write](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L341)
     * [zero_user_segments](http://lxr.free-electrons.com/source/include/linux/highmem.h?v=2.6.32#L140)
       * memsetで struct pageを '\0'初期化 [refs](http://lwn.net/Articles/234564/)
 * [iov_iter_fault_in_readable](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L1976)
   * ユーザ空間のアドレスを前もってページフォールト起こしておく `prefault`
   * ページフォルト失敗したら不正なアドレスてことで、止める
     * [fault_in_pages_readable](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L413)
 * pagefault_disable() ???
 * [iov_iter_copy_from_user_atomic](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L1892)
   * ユーザ空間のバッファをカーネル空間にコピるイテレータ
     * __copy_from_user ( Architecure Depends ) を繰り返す
 * pagefault_enable() ???
 * flush_dcache_page
   * x86 だと何も定義されてないぞ?
 * mark_page_accessed ???
 * .write_end
   * [simple_write_end](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L391)
     * [simple_commit_write](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L373)
     * [set_page_dirty](http://lxr.free-electrons.com/source/mm/page-writeback.c?v=2.6.32#L1168)
       * .set_page_dirty or [__set_page_dirty_buffers](http://lxr.free-electrons.com/source/fs/buffer.c?v=2.6.32#L710)
       * ページの内容が変わったので dirty になる
     * unlock_page で PG_locked を落とす
     * page_cache_release で参照カウントをデクリメント

struct *page の 割り当て、LRUへの追加、ユーザ空間のデータをコピー、page に書き込み、page is dirty

### __copy_from_user ( Architecure Depends )

```c
int __copy_from_user(void *dst, const void __user *src, unsigned size)
{
        int ret = 0;

        might_fault();
        if (!__builtin_constant_p(size))
                return copy_user_generic(dst, (__force void *)src, size);
        switch (size) {
        case 1:__get_user_asm(*(u8 *)dst, (u8 __user *)src,
                              ret, "b", "b", "=q", 1); 
                return ret;
        case 2:__get_user_asm(*(u16 *)dst, (u16 __user *)src,
                              ret, "w", "w", "=r", 2); 
                return ret;
        case 4:__get_user_asm(*(u32 *)dst, (u32 __user *)src,
                              ret, "l", "k", "=r", 4); 
                return ret;
        case 8:__get_user_asm(*(u64 *)dst, (u64 __user *)src,
                              ret, "q", "", "=r", 8); 
                return ret;
        case 10: 
                __get_user_asm(*(u64 *)dst, (u64 __user *)src,
                               ret, "q", "", "=r", 10);
                if (unlikely(ret))
                        return ret;
                __get_user_asm(*(u16 *)(8 + (char *)dst),
                               (u16 __user *)(8 + (char __user *)src),
                               ret, "w", "w", "=r", 2); 
                return ret;
        case 16: 
                __get_user_asm(*(u64 *)dst, (u64 __user *)src,
                               ret, "q", "", "=r", 16);
                if (unlikely(ret))
                        return ret;
                __get_user_asm(*(u64 *)(8 + (char *)dst),
                               (u64 __user *)(8 + (char __user *)src),
                               ret, "q", "", "=r", 8); 
                return ret;
        default:
                return copy_user_generic(dst, (__force void *)src, size);
        }   
}
```

### copy_user_generic

```
/* Some CPUs run faster using the string copy instructions.
 * This is also a lot simpler. Use them when possible.
 *
 * Only 4GB of copy is supported. This shouldn't be a problem
 * because the kernel normally only writes from/to page sized chunks
 * even if user space passed a longer buffer.
 * And more would be dangerous because both Intel and AMD have
 * errata with rep movsq > 4GB. If someone feels the need to fix
 * this please consider this.
 *
 * Input:
 * rdi destination
 * rsi source
 * rdx count
 *
 * Output:
 * eax uncopied bytes or 0 if successful.
 */
ENTRY(copy_user_generic_string)
	CFI_STARTPROC
	andl %edx,%edx
	jz 4f
	cmpl $8,%edx
	jb 2f		/* less than 8 bytes, go to byte copy loop */
	ALIGN_DESTINATION
	movl %edx,%ecx
	shrl $3,%ecx
	andl $7,%edx
1:	rep
	movsq
2:	movl %edx,%ecx
3:	rep
	movsb
4:	xorl %eax,%eax
	ret

	.section .fixup,"ax"
11:	lea (%rdx,%rcx,8),%rcx
12:	movl %ecx,%edx		/* ecx is zerorest also */
	jmp copy_user_handle_tail
	.previous

	.section __ex_table,"a"
	.align 8
	.quad 1b,11b
	.quad 3b,12b
	.previous
	CFI_ENDPROC
ENDPROC(copy_user_generic_string)
```

#### vboxfs
 
```c
struct address_space_operations sf_reg_aops =
{
    .readpage      = sf_readpage,
    .writepage     = sf_writepage,
# if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
    .write_begin   = sf_write_begin,
    .write_end     = sf_write_end,
# else
    .prepare_write = simple_prepare_write,
    .commit_write  = simple_commit_write,
# endif
};
#endif
```

 * sf_write_begin は simple_write_begin のラッパーで特になんもしてない (`TRACE()`を埋め込んでるだけ)

 ```c
# if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
int sf_write_begin(struct file *file, struct address_space *mapping, loff_t pos,
                   unsigned len, unsigned flags, struct page **pagep, void **fsdata)
{
    TRACE();
    // zero_user_segments で page の中身を ゼロ化
    return simple_write_begin(file, mapping, pos, len, flags, pagep, fsdata);
}
```

```
static inline void zero_user_segments(struct page *page,
	unsigned start1, unsigned end1,
	unsigned start2, unsigned end2)
{
    // kmap
	void *kaddr = kmap_atomic(page, KM_USER0);

	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);

    // kmap しといたら memset とかでいじれるということでおk?
	if (end1 > start1)
		memset(kaddr + start1, 0, end1 - start1);

	if (end2 > start2)
		memset(kaddr + start2, 0, end2 - start2);

	kunmap_atomic(kaddr, KM_USER0);
	flush_dcache_page(page);
}
```

 * sf_write_end は ページを kmap でごにょったり sf_reg_write_aux でホストOSと通信
 * `kmap、システムの任意のページのカーネル仮想アドレスをかえします`

```c
int sf_write_end(struct file *file, struct address_space *mapping, loff_t pos,
                 unsigned len, unsigned copied, struct page *page, void *fsdata)
{
    struct inode *inode = mapping->host;
    struct sf_glob_info *sf_g = GET_GLOB_INFO(inode->i_sb);
    struct sf_reg_info *sf_r = file->private_data;
    void *buf;
    // ファイルポジションからオフセットの算出
    unsigned from = pos & (PAGE_SIZE - 1);
    uint32_t nwritten = len;
    int err;

    TRACE();

    // buf = kmap(page)`
    // http://wiki.bit-hive.com/linuxkernelmemo/pg/HighMemory
    // 永続的カーネルマッピング Highメモリのページフレームをリニアドレスにマッピングする
    buf = kmap(page);
    err = sf_reg_write_aux(__func__, sf_g, sf_r, buf+from, &nwritten, pos);

    // マッピングの解除。必ず呼ばんといかんらしい
    kunmap(page);

    // PG_uptodate ... ページの読み込みが完了したときに設定する
    if (!PageUptodate(page) && err == PAGE_SIZE)
        SetPageUptodate(page);

    if (err >= 0) {
        pos += nwritten;
        if (pos > inode->i_size)
            inode->i_size = pos;
    }

    // simple_write_begin の grab_cache_page_write_begin が返す page は PG_locked なので
    // ここで PG_locked を外す (page を待ってブロックしている他タスクも起床される)
    unlock_page(page);

    // page の参照カウントをデクリメント
    // 参照カウントは simple_write_begin の中で page_cache_get されてインクリメントされている
    page_cache_release(page);

    return nwritten;
}

# endif /* KERNEL_VERSION 
```

 * sf_reg_write_aux は vboxCallWrite を呼んで buf の中身をホストOSのファイルシステムに書き込んでるはず
   * void *buf は kmap でリニアアドレス(物理アドレス) にマッピングされてる => 速いらしい
   * vboxCallWrite がホストOSとどうやり取りしてるかは TODO

```c
static int sf_reg_write_aux(const char *caller, struct sf_glob_info *sf_g,
                            struct sf_reg_info *sf_r, void *buf,
                            uint32_t *nwritten, uint64_t pos)
{
    /** @todo bird: yes, kmap() and kmalloc() input only. Since the buffer is
     *        contiguous in physical memory (kmalloc or single page), we should
     *        use a physical address here to speed things up. */

    // src/VBox/Additions/common/VBoxGuestLib/VBoxGuestR0LibSharedFolders.c
    int rc = vboxCallWrite(&client_handle, &sf_g->map, sf_r->handle,
                           pos, nwritten, buf, false /* already locked? */);
    if (RT_FAILURE(rc))
    {
        LogFunc(("vboxCallWrite failed. caller=%s, rc=%Rrc\n",
                    caller, rc));
        return -EPROTO;
    }
    return 0;
}
```

## ファイルシステムを作るにあたって実装が必要なんだろうまとめ

 * struct file_system_type
   * super_operations
 * fill_super()
 * rootディレクトリの VFS inode
      * [iget_locked](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32;a=m68k#L1067) で VFS inode 0番を割り当て
   * struct backing_dev_info
   * struct inode_operations
   * dir_inode_operations
   * address_space_operations ... ページの読み書き
   * file_operations ... VFSのインタフェースを実装 (read,write,...)
   * vm_operations ... 仮想メモリ用???

## memo

### dentry cache

 * do_lookup -> __d_llokup でキャッシュ探索 -> d_revalidate でキャッシュが有効かどうかを validate
   * real_lookup (filesystem-specific lookup action) -> .lookup

### /proc/filesystems の nodev の有無 とは?

`proc/filesystems` を cat すると nodev がついてるファイルシステムとそうでないのがある

```
[vagrant@vagrant-centos65 ~]$ cat /proc/filesystems 
nodev   sysfs
nodev   rootfs
nodev   bdev
nodev   proc
...
        iso9660
nodev   pstore
nodev   mqueue
        ext4
nodev   vboxsf
nodev   nukofs
```

 * `/proc/filesystems` 用に [file_systems_proc_show](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L220) がコールバックとして定義されている
   * `struct file_system_type` の fs_flags に [FS_REQUIRES_DEV](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L175) が立っているかどうかの違いらしい
   * `この種類の全てのファイルシステムは物理ディスクデバイス上に存在する必要がある`
   * FS_REQUIRES_DEV が立ってないファイルシステムは NFS で export もできない?

```c
static int filesystems_proc_show(struct seq_file *m, void *v)
{
	struct file_system_type * tmp;

	read_lock(&file_systems_lock);
	tmp = file_systems;
	while (tmp) {
		seq_printf(m, "%s\t%s\n",
			(tmp->fs_flags & FS_REQUIRES_DEV) ? "" : "nodev",
			tmp->name);
		tmp = tmp->next;
	}
	read_unlock(&file_systems_lock);
	return 0;
}
```

### sparse

 * http://www26.atwiki.jp/funa_tk/pages/33.html
   * __user, __iommem などの検査

### Pseudo-Filesystems

 * 擬似ファイルシステム
   * ユーザランドから mount することを許可しない (MS_NOUSER) ファイルシステム
     * sockfs, pipefs, bdev ..
   * kern_mount でマウントできる
   * .get_sb の flags | MS_NOUSER としておくと、mount 時にこんなんでる

```
mount: wrong fs type, bad option, bad superblock on nukofs,
       missing codepage or helper program, or other error
       (for several filesystems (e.g. nfs, cifs) you might
       need a /sbin/mount.<type> helper program)
       In some cases useful info is found in syslog - try
       dmesg | tail  or so
```

### vfs_write の const char __user *buf をいじる

do_sync_write をラップして遊ぶ

 * vfs_write の引数にある *buf は const がついているので、 kstrdup して変更を入れてみる
   * buf はユーザ空間のアドレスを差しているので、 copy_from_user ? が中でコケてるはず
   * write(2) は`Bad address` EFAULT を返す
   * ユーザ空間のバッファをいじるようなことは御法度である。南無

```c
static ssize_t nukofs_do_sync_write(struct file *filp, const char __user *buf,
			     size_t len, loff_t *ppos)
{
    /* バッファを複製 (長さ確認すべき) */
	char *modified = kstrdup(buf, GFP_KERNEL);

    /* 元の do_sync_write を呼ぶ */
	ssize_t size = do_sync_write(filp, modified, len, ppos);

    /* kstrdup のを kfree */
	kfree(modified);
	return size;
}
```

### /proc/sys/vm/drop_caches

drop_caches に 2 を write すると clean な dentry, inode を解放する

```
echo 2 | sudo tee /proc/sys/vm/drop_caches
```

 * simple_lookup は dentry のキャッシュミスが起こると呼ばれる
   * detnry がクリアされていれば simple_lookup が実行されるかと思いきや違った
   * 下記のようなデバッグの printk を仕込んだので検証

```c
/*
 * Retaining negative dentries for an in-memory filesystem just wastes
 * memory and lookup time: arrange for them to be deleted immediately.
 */
static int simple_delete_dentry(struct dentry *dentry)
{
	return 1;
}

struct dentry *nukofs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
{
	printk(KERN_INFO "dentry %s\n", dentry->d_name.name);
	
	static const struct dentry_operations simple_dentry_operations = {
		.d_delete = simple_delete_dentry,
	};

	if (dentry->d_name.len > NAME_MAX)
		return ERR_PTR(-ENAMETOOLONG);
	dentry->d_op = &simple_dentry_operations;
	d_add(dentry, NULL);
	return NULL;
}
```

RAMベースだと dentry は常に dirty 扱い ???

# カーネルモジュール tips

 * ライセンス表記の MODULE_LICENSE を入れておかないと insmod 時に warning がコンソールに出る
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x279.html
 * `__init`, `__exit` のアノテーションをつけておくと、モジュールをロード(アンロード)して関数実行後メモリが解放されてエコらしい
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x245.html
 * CentOS6 では Development Tools と kernel-devel を入れればビルドできる
 * Makefileのひな形

```
obj-m := sample.o
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)
default:
$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
```

 * [kmem_cache](http://www.ibm.com/developerworks/jp/linux/library/l-linux-slab-allocator/) API
   * kmem_cache_create であらかじめ登録しておく必要ある
   * init_once ってなんだ???

 * `address >> PAGE_SHIFT` で PFN (page frame number)
 * `address & (PAGE_SIZE - 1)` でオフセットを出す
 * `S_ISDIR(d_inode->i_mode);` ディレクトリかどうか

# TODO

 * vboxCallWrite がホストOSのプロセスの動きとどう関連するか
   * src/VBox/Additions/common/VBoxGuestLib/VBoxGuestR0LibSharedFolders.c 以下にソース有り
 * alloc_pages
 * SetPageSwapBacked
 * add_to_page_cache