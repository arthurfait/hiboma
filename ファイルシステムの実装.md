# ファイルシステムの実装

### 注意書き

 * 筆者の自習、教育的な用途を目的とした文章です
 * カーネルのバージョンは 2.6.32 ベースで記述しています
 * バニラカーネルのソースを掲載したページへのリンクを貼っているが、CentOSのカーネルはパッチが当たっているので、内容が全然一致しない場合があります
 * backing store を RAM にしたファイルシステムを念頭にしていて、ブロックデバイスのことは考えていません
   * ブロックデバイスベースのファイルシステムは複雑ぽいので、tmpfs と VirtualBox の vboxsf [ソース](https://www.virtualbox.org/wiki/Downloads)を参考に読み解いていく
      * vboxfs のソースは src/VBox/Additions/linux/sharedfolders 以下
   * 追記: tmpfs よりも ramfs の方が素朴な実装なので、最初に読むなら ramfs。ただし、カーネルのAPIをある程度知らないと逆に手がかかりがなさ過ぎるかも
   * 追記: fs/libfs.c の関数群も実装のヒントになる
 * 単語の定義を明確
   * _割り当て_ と書いた場合は、カーネルのメモリ管理APIで実メモリを確保していることを指すようにします (破棄はその逆)
   * _初期化_ と書いた場合は、メモリ割り当てされた構造体の未初期化のフィールドを初期化することを指すようにします
   * _実装_ と書いた場合は、モジュール作成者が任意のコードを書く必要があることを指すようにします
 * [https://github.com/hiboma/nukofs](https://github.com/hiboma/nukofs) に学習用の実装を残しています

## ファイルシステムをカーネルモジュールとして実装する
 
 * Linuxのファイルシステムはカーネルモジュールとして実装できます
   * OSが起動中に動的にロード可能、もしくは削除可能

## [struct file_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1489) の実装

```
ファイルの読み取りや下記k未などの操作を行う、ファイルシステムごとに固有のファイル操作(file operation)関数群があります
```

 * inode->i_fop メンバ
 * open(2) ないと呼べないよね? ( `struct file` を確保しているのが前提)

### read(2) が Invalid argument [#19](https://github.com/hiboma/nukofs/issues/19)

 * vfs_read が file_operations の .read と .aio_write が無い場合は -EINVAL 返す

```c
ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
	ssize_t ret;

	if (!(file->f_mode & FMODE_READ))
		return -EBADF;
	if (!file->f_op || (!file->f_op->read && !file->f_op->aio_read))
		return -EINVAL;
	if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
		return -EFAULT;

	ret = rw_verify_area(READ, file, pos, count);
	if (ret >= 0) {
		count = ret;
		if (file->f_op->read)
			ret = file->f_op->read(file, buf, count, pos);
		else
			ret = do_sync_read(file, buf, count, pos);
		if (ret > 0) {
			fsnotify_access(file->f_path.dentry);
			add_rchar(current, ret);
		}
		inc_syscr(current);
	}

	return ret;
}
```

 * do_sync_read って書いてるのに aio_read に繋がるのね

```c
ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
{
	struct iovec iov = { .iov_base = buf, .iov_len = len };
	struct kiocb kiocb;
	ssize_t ret;

	init_sync_kiocb(&kiocb, filp);
	kiocb.ki_pos = *ppos;
	kiocb.ki_left = len;

	for (;;) {
		ret = filp->f_op->aio_read(&kiocb, &iov, 1, kiocb.ki_pos);
		if (ret != -EIOCBRETRY)
			break;
		wait_on_retry_sync_kiocb(&kiocb);
	}

	if (-EIOCBQUEUED == ret)
		ret = wait_on_sync_kiocb(&kiocb);
	*ppos = kiocb.ki_pos;
	return ret;
}
```

### write(2) が Invalid argument [#11](https://github.com/hiboma/nukofs/issues/11)

 * [sys_write](http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.32#L389) -> [vfs_write](http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.32#L332)
   * 以下の通り、file_operations の .write または aio_write を実装しておかないと EINVAL を返す

```c
ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
	ssize_t ret;

	if (!(file->f_mode & FMODE_WRITE))
		return -EBADF;
	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
		return -EINVAL;
	if (unlikely(!access_ok(VERIFY_READ, buf, count)))
		return -EFAULT;

	ret = rw_verify_area(WRITE, file, pos, count);
	if (ret >= 0) {
		count = ret;
		if (file->f_op->write)
			ret = file->f_op->write(file, buf, count, pos);
		else
			ret = do_sync_write(file, buf, count, pos);
		if (ret > 0) {
			fsnotify_modify(file->f_path.dentry);
			add_wchar(current, ret);
		}
		inc_syscw(current);
	}

	return ret;
}
```

`struct file_operations` の .write, .aio_write を実装しよう ↓

#### .write と .aio_write だけ初期化してみたところ panic

![](https://f.cloud.github.com/assets/172456/1949504/47a3daf4-810c-11e3-934c-21473ef89139.png)

 * `struct address_space_operations` の実装も必要だった様子
   * generic_file_aio_write がページキャッシュにデータを載せるため
      * O_DIRECT を指定した際に呼ばれる generic_file_direct_write と比較するとページキャッシュの差が分かりやすい?
      * generic_file_buffered_write の有無 によって差がでる
   * .write_begin, .write_end が必要
     * [simple_write_begin](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L353), [simple_write_end](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L391) が用意されている
     * simple_write_begin は strct *page を割り当て、[simple_prepare_write](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L341) で page の中身をゼロクリア
       * ここでの page は PG_locked
   * .write_page はいらんみたい => ???

#### ramfs, tmpfs

 * [do_sync_write](http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=2.6.32#L40) を使ってる
   * do_sync_write は file_->f_op->aio_write を呼び出してる。 結局 .aio_write が必要なのかn
   * `const char __user *buf` は `struct iovec iov` にまとめられる
 * [generic_file_aio_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2464)
   * `mutex_lock(&inode->i_mutex)` -> inode 単位で直列化
   * [__generic_file_aio_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2334)
     * `current->backing_dev_info = mapping->backing_dev_info`
     * [generic_file_buffered_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2304)
       * [generic_perform_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2212)
       * address_space_operations の .write_begin , .write_end が呼ばれる => 後述

aio は [POSIX AIO](http://linuxjm.sourceforge.jp/html/LDP_man-pages/man7/aio.7.html) とは違う(よね)

## [struct address_space_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L570) の実装

 * struct file_operations と一緒に実装する必要あり
 * RAMベースのファイルシステムでは address_space = ページキャッシュ がストレージとして機能する

### ramfs

```c
const struct address_space_operations ramfs_aops = {
	.readpage	= simple_readpage,
	.write_begin	= simple_write_begin,
	.write_end	= simple_write_end,
	.set_page_dirty = __set_page_dirty_no_writeback,
};
```

#### .write_begin

 * ページに書き込むにはまずはページの確保が必要
   * 新しく割り当てるか? ページキャッシュから探索して見つかるか?
   * ページは .write_begin 〜 .write_end の間ロックされる
   * ページ確保は grab_cache_page_write_begin で実装される

```c
int simple_write_begin(struct file *file, struct address_space *mapping,
			loff_t pos, unsigned len, unsigned flags,
			struct page **pagep, void **fsdata)
{
	struct page *page;
	pgoff_t index;
	unsigned from;

	index = pos >> PAGE_CACHE_SHIFT;
	from = pos & (PAGE_CACHE_SIZE - 1);

	page = grab_cache_page_write_begin(mapping, index, flags);
	if (!page)
		return -ENOMEM;

	*pagep = page;

	return simple_prepare_write(file, page, from, from+len);
}
```

grab_cache_page_write_begin

 * find_lock_page
   * ページキャッシュからページを探索、ロックを取る
 * __page_cache_alloc
   * 新しくページを確保したら LRU に繋ぐ add_to_page_cache_lru

```c
/*
 * Find or create a page at the given pagecache position. Return the locked
 * page. This function is specifically for buffered writes.
 */
struct page *grab_cache_page_write_begin(struct address_space *mapping,
					pgoff_t index, unsigned flags)
{
	int status;
	struct page *page;
	gfp_t gfp_notmask = 0;
	if (flags & AOP_FLAG_NOFS)
		gfp_notmask = __GFP_FS;
repeat:
    // ページキャッシュで探索
    // 並行して同じページに書き込みが内容にロックを取る
    // ページのロックを取れない場合は TASK_UNINTERRUPTIBLE
	page = find_lock_page(mapping, index);
	if (likely(page))
		return page;

    // ページの割り当て
	page = __page_cache_alloc(mapping_gfp_mask(mapping) & ~gfp_notmask);
	if (!page)
		return NULL;

    // ページキャッシュLRU への追加
	status = add_to_page_cache_lru(page, mapping, index,
						GFP_KERNEL & ~gfp_notmask);
	if (unlikely(status)) {
		page_cache_release(page);
		if (status == -EEXIST)
			goto repeat;
		return NULL;
	}
	return page;
}
EXPORT_SYMBOL(grab_cache_page_write_begin);
```

simple_prepare_write

 * 書き込んだサイズ ( to - from ) が PAGE_CACHE_SIZE 以下なら余った部分を zero 化
   * 余計なデータがユーザ空間から参照できないようにするため?

```c
int simple_prepare_write(struct file *file, struct page *page,
			unsigned from, unsigned to)
{
	if (!PageUptodate(page)) {
		if (to - from != PAGE_CACHE_SIZE)
			zero_user_segments(page,
				0, from,
				to, PAGE_CACHE_SIZE);
	}
	return 0;
}
```

#### .write_end

 * ページに書き込んだサイズがページ以下なら memset zero化
   * commit_write でページを dirty に

```c
int simple_write_end(struct file *file, struct address_space *mapping,
			loff_t pos, unsigned len, unsigned copied,
			struct page *page, void *fsdata)
{
	unsigned from = pos & (PAGE_CACHE_SIZE - 1);

	/* zero the stale part of the page if we did a short copy */
	if (copied < len) {
        // ?
		void *kaddr = kmap_atomic(page, KM_USER0);

        // kaddr   from               copied  len
        // /------/-------------------/------/
        // |      |###################|      |
        // +--------------------------\------+
        //                           kaddr+from+len
		memset(kaddr + from + copied, 0, len - copied);
        // アーキテチャ依存 x86 は空になっている
		flush_dcache_page(page);
		kunmap_atomic(kaddr, KM_USER0);
	}

	simple_commit_write(file, page, from, from+copied);

	unlock_page(page);
	page_cache_release(page);

	return copied;
}
```

simple_commit_write

 * set_page_dirty でページに dirty フラグを立てる
   * 内部で address_space の .set_page_dirty が呼ばれている
   * RAMベースだと __set_page_dirty_no_writeback 呼ぶだけ
   
```c
static int simple_commit_write(struct file *file, struct page *page,
			       unsigned from, unsigned to)
{
	struct inode *inode = page->mapping->host;
	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;

	if (!PageUptodate(page))
		SetPageUptodate(page);
	/*
	 * No need to use i_size_read() here, the i_size
	 * cannot change under us because we hold the i_mutex.
	 */
	if (pos > inode->i_size)
		i_size_write(inode, pos);
	set_page_dirty(page);
	return 0;
}
```

__set_page_dirty_no_writeback

``` c
/*
 * For address_spaces which do not use buffers nor write back.
 */
int __set_page_dirty_no_writeback(struct page *page)
{
	if (!PageDirty(page))
		SetPageDirty(page);
	return 0;
}
```

### tmpfs

 * tmpfs はスワップも絡んでくるので w大分ややこしい

```c
static const struct address_space_operations shmem_aops = {
	.writepage	= shmem_writepage,
	.set_page_dirty	= __set_page_dirty_no_writeback,
#ifdef CONFIG_TMPFS
	.write_begin	= shmem_write_begin,
	.write_end	= shmem_write_end,
#endif
	.migratepage	= migrate_page,
    // メモリが物故割れた際にページを取り除く?らしい
	.error_remove_page = generic_error_remove_page,
};
```

### vfs_write から address_space_operations に下るところを追う

[generic_perform_write](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2212) is 複雑 !!!

 * .write_begin 
   * [simple_write_begin](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L353)
     * [grab_cache_page_write_begin](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L2184)
       * find_lock_page で アドレス空間から指定したインデックスを持つ struct *page を返す。page は PG_locked
         * ロックを取れない場合は TASK_UNINTERRUPTIBLE でブロック
           * 並行して同一のページに書き込みを防ぐため
         * struct *page は ページフレーム に対応 => 同じページフレームに複数のタスク(割り込みコンテキストは?)から同時書き込みできない
       * [__page_cache_alloc](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L483)
         * struct *page を割り当て
           * NUMAに対応するためにどのメモリノードからページを取るか allow_pages_excat_node で指定
         * alloc_pages 以下は複雑なので別件で追う
       * [add_to_page_cache_lru](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L457)
         * mapping_cap_swap_backed(struct address_space) で address_space が swap 可能かどうかを見ている
           * backing_dev_info の capabilities に BDI_CAP_SWAP_BACKED が立っているか否か
           * tmpfs の場合 true
             * SetPageSwapBacked(page) ???
         * [add_to_page_cache](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L443) ???
         * lru_cache_add_file => LRU_INACTIVE_FILE リストに繋ぐ
         * lru_cache_add_anon => LRU_INACTIVE_ANON リストに繋ぐ
   * [simple_prepare_write](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L341)
     * [zero_user_segments](http://lxr.free-electrons.com/source/include/linux/highmem.h?v=2.6.32#L140) 
       * memsetで struct pageを '\0'初期化 [refs](http://lwn.net/Articles/234564/)
 * [iov_iter_fault_in_readable](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L1976)
   * ユーザ空間のアドレスを前もってページフォールト起こしておく `prefault`
   * ページフォルト失敗したら不正なアドレスてことで、止める
     * [fault_in_pages_readable](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L413)
 * pagefault_disable() ???
 * [iov_iter_copy_from_user_atomic](http://lxr.free-electrons.com/source/mm/filemap.c?v=2.6.32#L1892)
   * ユーザ空間のバッファをカーネル空間にコピるイテレータ
     * __copy_from_user ( Architecure Depends ) を繰り返す
 * pagefault_enable() ???
 * flush_dcache_page
   * x86 だと何も定義されてないぞ?
 * mark_page_accessed ???
 * .write_end
   * [simple_write_end](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L391)
     * [simple_commit_write](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L373)
     * [set_page_dirty](http://lxr.free-electrons.com/source/mm/page-writeback.c?v=2.6.32#L1168)
       * .set_page_dirty or [__set_page_dirty_buffers](http://lxr.free-electrons.com/source/fs/buffer.c?v=2.6.32#L710)
       * ページの内容が変わったので dirty になる
     * unlock_page で PG_locked を落とす
     * page_cache_release で参照カウントをデクリメント

struct *page の 割り当て、LRUへの追加、ユーザ空間のデータをコピー、page に書き込み、page is dirty

### __copy_from_user ( Architecure Depends )

```c
int __copy_from_user(void *dst, const void __user *src, unsigned size)
{
        int ret = 0;

        might_fault();
        if (!__builtin_constant_p(size))
                return copy_user_generic(dst, (__force void *)src, size);
        switch (size) {
        case 1:__get_user_asm(*(u8 *)dst, (u8 __user *)src,
                              ret, "b", "b", "=q", 1); 
                return ret;
        case 2:__get_user_asm(*(u16 *)dst, (u16 __user *)src,
                              ret, "w", "w", "=r", 2); 
                return ret;
        case 4:__get_user_asm(*(u32 *)dst, (u32 __user *)src,
                              ret, "l", "k", "=r", 4); 
                return ret;
        case 8:__get_user_asm(*(u64 *)dst, (u64 __user *)src,
                              ret, "q", "", "=r", 8); 
                return ret;
        case 10: 
                __get_user_asm(*(u64 *)dst, (u64 __user *)src,
                               ret, "q", "", "=r", 10);
                if (unlikely(ret))
                        return ret;
                __get_user_asm(*(u16 *)(8 + (char *)dst),
                               (u16 __user *)(8 + (char __user *)src),
                               ret, "w", "w", "=r", 2); 
                return ret;
        case 16: 
                __get_user_asm(*(u64 *)dst, (u64 __user *)src,
                               ret, "q", "", "=r", 16);
                if (unlikely(ret))
                        return ret;
                __get_user_asm(*(u64 *)(8 + (char *)dst),
                               (u64 __user *)(8 + (char __user *)src),
                               ret, "q", "", "=r", 8); 
                return ret;
        default:
                return copy_user_generic(dst, (__force void *)src, size);
        }   
}
```

### copy_user_generic

```
/* Some CPUs run faster using the string copy instructions.
 * This is also a lot simpler. Use them when possible.
 *
 * Only 4GB of copy is supported. This shouldn't be a problem
 * because the kernel normally only writes from/to page sized chunks
 * even if user space passed a longer buffer.
 * And more would be dangerous because both Intel and AMD have
 * errata with rep movsq > 4GB. If someone feels the need to fix
 * this please consider this.
 *
 * Input:
 * rdi destination
 * rsi source
 * rdx count
 *
 * Output:
 * eax uncopied bytes or 0 if successful.
 */
ENTRY(copy_user_generic_string)
	CFI_STARTPROC
	andl %edx,%edx
	jz 4f
	cmpl $8,%edx
	jb 2f		/* less than 8 bytes, go to byte copy loop */
	ALIGN_DESTINATION
	movl %edx,%ecx
	shrl $3,%ecx
	andl $7,%edx
1:	rep
	movsq
2:	movl %edx,%ecx
3:	rep
	movsb
4:	xorl %eax,%eax
	ret

	.section .fixup,"ax"
11:	lea (%rdx,%rcx,8),%rcx
12:	movl %ecx,%edx		/* ecx is zerorest also */
	jmp copy_user_handle_tail
	.previous

	.section __ex_table,"a"
	.align 8
	.quad 1b,11b
	.quad 3b,12b
	.previous
	CFI_ENDPROC
ENDPROC(copy_user_generic_string)
```

#### vboxfs
 
```c
struct address_space_operations sf_reg_aops =
{
    .readpage      = sf_readpage,
    .writepage     = sf_writepage,
# if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
    .write_begin   = sf_write_begin,
    .write_end     = sf_write_end,
# else
    .prepare_write = simple_prepare_write,
    .commit_write  = simple_commit_write,
# endif
};
#endif
```

 * sf_write_begin は simple_write_begin のラッパーで特になんもしてない (`TRACE()`を埋め込んでるだけ)

 ```c
# if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
int sf_write_begin(struct file *file, struct address_space *mapping, loff_t pos,
                   unsigned len, unsigned flags, struct page **pagep, void **fsdata)
{
    TRACE();
    // zero_user_segments で page の中身を ゼロ化
    return simple_write_begin(file, mapping, pos, len, flags, pagep, fsdata);
}
```

```
static inline void zero_user_segments(struct page *page,
	unsigned start1, unsigned end1,
	unsigned start2, unsigned end2)
{
    // kmap
	void *kaddr = kmap_atomic(page, KM_USER0);

	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);

    // kmap しといたら memset とかでいじれるということでおk?
	if (end1 > start1)
		memset(kaddr + start1, 0, end1 - start1);

	if (end2 > start2)
		memset(kaddr + start2, 0, end2 - start2);

	kunmap_atomic(kaddr, KM_USER0);
	flush_dcache_page(page);
}
```

 * sf_write_end は ページを kmap でごにょったり sf_reg_write_aux でホストOSと通信
 * `kmap、システムの任意のページのカーネル仮想アドレスをかえします`

```c
int sf_write_end(struct file *file, struct address_space *mapping, loff_t pos,
                 unsigned len, unsigned copied, struct page *page, void *fsdata)
{
    struct inode *inode = mapping->host;
    struct sf_glob_info *sf_g = GET_GLOB_INFO(inode->i_sb);
    struct sf_reg_info *sf_r = file->private_data;
    void *buf;
    // ファイルポジションからオフセットの算出
    unsigned from = pos & (PAGE_SIZE - 1);
    uint32_t nwritten = len;
    int err;

    TRACE();

    // buf = kmap(page)`
    // http://wiki.bit-hive.com/linuxkernelmemo/pg/HighMemory
    // 永続的カーネルマッピング Highメモリのページフレームをリニアドレスにマッピングする
    buf = kmap(page);
    err = sf_reg_write_aux(__func__, sf_g, sf_r, buf+from, &nwritten, pos);

    // マッピングの解除。必ず呼ばんといかんらしい
    kunmap(page);

    // PG_uptodate ... ページの読み込みが完了したときに設定する
    if (!PageUptodate(page) && err == PAGE_SIZE)
        SetPageUptodate(page);

    if (err >= 0) {
        pos += nwritten;
        if (pos > inode->i_size)
            inode->i_size = pos;
    }

    // simple_write_begin の grab_cache_page_write_begin が返す page は PG_locked なので
    // ここで PG_locked を外す (page を待ってブロックしている他タスクも起床される)
    unlock_page(page);

    // page の参照カウントをデクリメント
    // 参照カウントは simple_write_begin の中で page_cache_get されてインクリメントされている
    page_cache_release(page);

    return nwritten;
}

# endif /* KERNEL_VERSION 
```

 * sf_reg_write_aux は vboxCallWrite を呼んで buf の中身をホストOSのファイルシステムに書き込んでるはず
   * void *buf は kmap でリニアアドレス(物理アドレス) にマッピングされてる => 速いらしい
   * vboxCallWrite がホストOSとどうやり取りしてるかは TODO

```c
static int sf_reg_write_aux(const char *caller, struct sf_glob_info *sf_g,
                            struct sf_reg_info *sf_r, void *buf,
                            uint32_t *nwritten, uint64_t pos)
{
    /** @todo bird: yes, kmap() and kmalloc() input only. Since the buffer is
     *        contiguous in physical memory (kmalloc or single page), we should
     *        use a physical address here to speed things up. */

    // src/VBox/Additions/common/VBoxGuestLib/VBoxGuestR0LibSharedFolders.c
    int rc = vboxCallWrite(&client_handle, &sf_g->map, sf_r->handle,
                           pos, nwritten, buf, false /* already locked? */);
    if (RT_FAILURE(rc))
    {
        LogFunc(("vboxCallWrite failed. caller=%s, rc=%Rrc\n",
                    caller, rc));
        return -EPROTO;
    }
    return 0;
}
```

## ファイルシステムを作るにあたって実装が必要なんだろうまとめ

 * struct file_system_type
   * super_operations
 * fill_super()
 * rootディレクトリの VFS inode
      * [iget_locked](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32;a=m68k#L1067) で VFS inode 0番を割り当て
   * struct backing_dev_info
   * struct inode_operations
   * dir_inode_operations
   * address_space_operations ... ページの読み書き
   * file_operations ... VFSのインタフェースを実装 (read,write,...)
   * vm_operations ... 仮想メモリ用???

## memo

### dentry cache

 * do_lookup -> __d_llokup でキャッシュ探索 -> d_revalidate でキャッシュが有効かどうかを validate
   * real_lookup (filesystem-specific lookup action) -> .lookup

### /proc/filesystems の nodev の有無 とは?

`proc/filesystems` を cat すると nodev がついてるファイルシステムとそうでないのがある

```
[vagrant@vagrant-centos65 ~]$ cat /proc/filesystems 
nodev   sysfs
nodev   rootfs
nodev   bdev
nodev   proc
...
        iso9660
nodev   pstore
nodev   mqueue
        ext4
nodev   vboxsf
nodev   nukofs
```

 * `/proc/filesystems` 用に [file_systems_proc_show](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L220) がコールバックとして定義されている
   * `struct file_system_type` の fs_flags に [FS_REQUIRES_DEV](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L175) が立っているかどうかの違いらしい
   * `この種類の全てのファイルシステムは物理ディスクデバイス上に存在する必要がある`
   * FS_REQUIRES_DEV が立ってないファイルシステムは NFS で export もできない?

```c
static int filesystems_proc_show(struct seq_file *m, void *v)
{
	struct file_system_type * tmp;

	read_lock(&file_systems_lock);
	tmp = file_systems;
	while (tmp) {
		seq_printf(m, "%s\t%s\n",
			(tmp->fs_flags & FS_REQUIRES_DEV) ? "" : "nodev",
			tmp->name);
		tmp = tmp->next;
	}
	read_unlock(&file_systems_lock);
	return 0;
}
```

### sparse

 * http://www26.atwiki.jp/funa_tk/pages/33.html
   * __user, __iommem などの検査

### Pseudo-Filesystems

 * 擬似ファイルシステム
   * ユーザランドから mount することを許可しない (MS_NOUSER) ファイルシステム
     * sockfs, pipefs, bdev ..
   * kern_mount でマウントできる
   * .get_sb の flags | MS_NOUSER としておくと、mount 時にこんなんでる

```
mount: wrong fs type, bad option, bad superblock on nukofs,
       missing codepage or helper program, or other error
       (for several filesystems (e.g. nfs, cifs) you might
       need a /sbin/mount.<type> helper program)
       In some cases useful info is found in syslog - try
       dmesg | tail  or so
```

### vfs_write の const char __user *buf をいじる

do_sync_write をラップして遊ぶ

 * vfs_write の引数にある *buf は const がついているので、 kstrdup して変更を入れてみる
   * buf はユーザ空間のアドレスを差しているので、 copy_from_user ? が中でコケてるはず
   * write(2) は`Bad address` EFAULT を返す
   * ユーザ空間のバッファをいじるようなことは御法度である。南無

```c
static ssize_t nukofs_do_sync_write(struct file *filp, const char __user *buf,
			     size_t len, loff_t *ppos)
{
    /* バッファを複製 (長さ確認すべき) */
	char *modified = kstrdup(buf, GFP_KERNEL);

    /* 元の do_sync_write を呼ぶ */
	ssize_t size = do_sync_write(filp, modified, len, ppos);

    /* kstrdup のを kfree */
	kfree(modified);
	return size;
}
```

### /proc/sys/vm/drop_caches

drop_caches に 2 を write すると clean な dentry, inode を解放する

```
echo 2 | sudo tee /proc/sys/vm/drop_caches
```

 * simple_lookup は dentry のキャッシュミスが起こると呼ばれる
   * detnry がクリアされていれば simple_lookup が実行されるかと思いきや違った
   * 下記のようなデバッグの printk を仕込んだので検証

```c
/*
 * Retaining negative dentries for an in-memory filesystem just wastes
 * memory and lookup time: arrange for them to be deleted immediately.
 */
static int simple_delete_dentry(struct dentry *dentry)
{
	return 1;
}

struct dentry *nukofs_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
{
	printk(KERN_INFO "dentry %s\n", dentry->d_name.name);
	
	static const struct dentry_operations simple_dentry_operations = {
		.d_delete = simple_delete_dentry,
	};

	if (dentry->d_name.len > NAME_MAX)
		return ERR_PTR(-ENAMETOOLONG);
	dentry->d_op = &simple_dentry_operations;
	d_add(dentry, NULL);
	return NULL;
}
```

RAMベースだと dentry は常に dirty 扱い ???

# カーネルモジュール tips

 * ライセンス表記の MODULE_LICENSE を入れておかないと insmod 時に warning がコンソールに出る
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x279.html
 * `__init`, `__exit` のアノテーションをつけておくと、モジュールをロード(アンロード)して関数実行後メモリが解放されてエコらしい
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x245.html
 * CentOS6 では Development Tools と kernel-devel を入れればビルドできる
 * Makefileのひな形

```
obj-m := sample.o
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)
default:
$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
```

 * [kmem_cache](http://www.ibm.com/developerworks/jp/linux/library/l-linux-slab-allocator/) API
   * kmem_cache_create であらかじめ登録しておく必要ある
   * init_once ってなんだ???

 * `address >> PAGE_SHIFT` で PFN (page frame number)
 * `address & (PAGE_SIZE - 1)` でオフセットを出す
 * `S_ISDIR(d_inode->i_mode);` ディレクトリかどうか

# TODO

 * vboxCallWrite がホストOSのプロセスの動きとどう関連するか
   * src/VBox/Additions/common/VBoxGuestLib/VBoxGuestR0LibSharedFolders.c 以下にソース有り
 * alloc_pages
 * SetPageSwapBacked
 * add_to_page_cache