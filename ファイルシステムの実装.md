# ファイルシステムの実装

### 注意書き

 * カーネルのバージョンは 2.6.32 ベースで記述しています
 * バニラカーネルのソースを掲載したページへのリンクを貼っているが、CentOSのカーネルはパッチが当たっているので、内容が全然一致しない場合がある
   * ex. cgroup 周りの実装はぜんぜん違う
 * backing store を RAM にしたファイルシステムを念頭にしていて、ブロックデバイスのことは考えていない
   
## カーネルモジュール

Linuxのファイルシステムはカーネルモジュールとして実装できてローダブル

## モジュールの modules_init で register_filesystem を呼びファイルシステムを登録する
 
俺俺のファイルシステムを登録するにあたって [struct file_system_type](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1745) を定義する

 * カーネルモジュールの modules_initマクロに定義した関数内で [register_filesystem](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L56) で登録したらよい
 * 削除するときは  modules_exitsマクロに定義した関数内で [unregister_filesystem](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L90) を呼べばよい
 
register_filesystem はファイルシステムのリストに繋げるだけで、後述する .get_sb, .kill_sb らへんの super_block の操作は何も関係ない様子
 
## struct file_system_type の定義

ファイルシステム名の登録( _/proc/filesystems_ で参照できる ) とsuper_block のコンストラクタ/デストラクタを実装するのが目的

 * struct fils_system_type の .get_sb と .kill_sb フィールドの実装が必要
   * ひな形として流用できる関数が用意しされているので利用する
 * .get_sb 
   * [get_sb_nodev](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L855) をラップすればよい
   * デバイスを持たないファイルシステムで superblock を取得するための関数 [#](http://filesystem.g.hatena.ne.jp/n314/20080325/1206426881)
    * get_sb_nodev の中で [sget](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L338) が superblock *sb のメモリを割り当ててくれる
       * [alloc_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L54) で `kzalloc(sizeof(struct super_block),  GFP_USER);` で割当
    * fill_super関数ポインタを実装して superblock のフィールドを初期化する必要がある
 * kill_sb 
   * kill_anon_super/kill_litter_super を使えばよい

__misc__

 * .get_sb フィールドは 2.6.39 まで。それ以降は .mount になる (vboxfsを参照)
   * get_sb_nodev が変わり mount_nodev になる
 * [kill_litter_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L703) は [kill_anon_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L689) のラッパーで[d_genocide](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L2176) を呼ぶ
   * d_genocide は root dentry から辿って全てのサブディレクトリ以下の dentry の参照カウントをデクリメントする
      * デクリメントするだけで dentry の破棄はしないぽい
      * kill_anon_super -> [generic_shutdown_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L693) で [shrink_dcache_for_umount](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L302) を呼んで dentry のキャッシュを破棄する
   * kill_anon_super の ___anon___ は super_block と結びついた block device が無いことを指すのだろう (anonymouse page 的な)

## superblock の初期化 fill_super の役割

 * ファイルシステムの superblock と、ファイルシステムの root ディレクトリとなる VFS inode/dentry の割当て、初期化をする必要がある
 * fill_superの型をもつ関数ポインタを実装して get_sb_nodev に渡す形式
   * vboxsf は sf_read_super_auxで実装している 
   * tmpfs は [shmem_fill_super](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2305) で実装している

なおここでの __inode__ はカーネルのメモリ上で扱われるVFSの `struct inode` のことで、backing store の inode 情報のことではない。backing store の inode 情報を VFSの `struct inode` にマップするのはまた別の話

### fill_super の詳細

```
(int *fill_super)(struct super_block *sb, void *data, int silent)
```

`struct super_block *sb` は [get_sb_nodev](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L855) の中で [sget](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L338) -> [alloc_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L54 )で割り当てられたもので、下記の各種フィールドが初期化されていない

 * ブロックサイズ 
   * tmpfs は PAGE_CACHE_SIZE = PAGE_SIZE で指定されている
   * vboxsf は 1024 
 * ブロックサイズをビット値で表した数値 (つまりブロックサイズは2の倍数である必要がある) 
   * tmpfs は PAGE_CACHE_SHIFT = PAGE_SHIFT = 12 (4096) で指定されている
   * vboxsf は未定義
 * マジックナンバー
 * 最大ファイルサイズ
 * super_operations
   * vboxfs は sf_super_ops
   * tmpfs は [shmem_ops](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2488)
 * root になる dentry 
  * rootディレクトリの inode を作り、さらに [d_alloc_root](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L1085) で root dentry を割り当てる必要がある
    * tmpfs の場合 [shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541) の [new_inode](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32#L655) から inode を作る
       * root dentry 用以外の inode も作れるように汎用的になっている
    * vboxsf の場合 `iget_locked(sb, 0)` で 0番の inode を作る
 * ctime, mtime, atime の粒度?
 
全てのフィールドを明示的に許可しなくてもよい様子
    
__misc__

 * get_sb_nodev 以外にも get_sb_pseudo, get_sb_block などある
   * ファイルシステムのバックエンドに応じて呼び出せばよい?

## ファイルシステムの rootディレクトリとなる inode の初期化

[inode]:

 * rootディレクトリのVFS inode を作成し、パーミッション, uid/gid, 各種operations を初期化する必要がある
 * ブロックデバイスベースのファイルシステムの場合は、デバイスからrootディレクトリのinode情報を読み取って初期化する必要がある
 * RAMベースの場合は、ファイルシステムの都合で適当に初期化しておけば良い
 
### struct inode 各種フィールド
 
 * i_mode 
    * パーミッションはファイルシステムのポリシーで任意
    * i_mode に S_IFDIR 足しとかないと mount(2) で ENOTDIR `Not a directory` 返すので注意
 * uid,gid
 * atime, mtime, ctime
    * CURRENT_TIMEマクロを使うと現在時刻で初期化できる
 * i_mapping->backing_dev_info [後述][backing_dev_info]
 * i_mapping->a_ops
 * ファイルの場合は
   * inode_operations
   * file_operations
 * ディレクトリの場合は
   * dir_inode_operations
   * dir_operations
 * nlink リンク数
 * ブロック数

__misc__

 * vboxsf はホストOSの共有フォルダの情報を sf_stat で調べて、sf_init_inode で適宜埋める様子
 * tmpfs の場合 shmem_get_inode [#](http://lxr.free-electrons.com/ident?v=2.6.32&i=shmem_get_inode) で初期化している   
 * その他 dquot_operations, quotactl_ops, export_operations (nfs) は必要なら適宜初期化したらよい様子
 * tmpfs では俺俺の struct shmem_sb_info を sb->s_fs_info に入れている
   * `void * s_fs_info /* Filesystem private info */` とあるので、ファイルシステム固有のデータを入れとく用途
   * tmpfsでは各種制限が設けられていて、その閾値をぶっ込んでいる
    * shmem_default_max_blocks で ブロックの最大数を totalram_pages / 2 [#](http://wiki.bit-hive.com/north/pg/%A5%C8%A1%BC%A5%BF%A5%EB%A5%E1%A5%E2%A5%EA) としている
    * shmem_default_max_inodes で inodeの最大数を min(totalram_pages - totalhigh_pages, totalram_pages / 2); にしている
 * tmpfs として利用する場合は MS_NOUSERフラグが落ちてる
 
## backing_dev_info とは?

[backing_dev_info]:

* アドレス空間の背後にある周辺機器(peripheral device)を __Backing store__ と呼ぶ (refs Linux Kernel Architecture p.957 )
* ふつーはブロックデバイスだけど、もちろんRAMベースもある。

backing store のメタデータを入れておくのが __struct backing_dev_info__ [#](http://lxr.free-electrons.com/source/include/linux/backing-dev.h?v=2.6.32#L60)

 * bdi_initで登録, bdi_destroy で破棄

### backing_dev_info のフィールド

 * ra_pages 
   * 先読みするページの最大数を指定(readahead pages)
   * RAMだと先読みいらんし、ブロックデバイスだけで有効かな
 * capabilities 
   * ページを backing store と同期(write back)する際のポリシーなどを指定
   * ブロックデバイスだと必要だけど RAM だといらん 
   * mmap できるかなども指定するぽい   
     * BDI_CAP_NO_ACCT_AND_WRITEBACK
     * BDI_CAP_NO_ACCT_DIRTY RAM backing store だとページが dirty かどうかの判定いらん
     * これらのフラグがどうやって利用されてるかが謎。
 * dev 
   * struct device 入れておく。 RAM backing store だと null 入れておkらしい
   
## super_operations の実装 [#](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1562) 

RAMベースだと全てを実装する必要は無い。

### vboxfsの実装

2.6.32用のvboxfsで実装されるフィールドは下記の4つ

 * .clear_inode
   * inode->private から sf_inode_info を取り出して kfree
 * .put_user 
   * umount(2) して super_blockを解放する時に呼ぶ?
   * super_block から sf_glob_info を取り出して、backing_dev を bdi_destroy してる
   * vboxCallUnmapFolder でホストOSのフォルダとのマップを解除
 * .statfs
 * .remount_fs 
 
vboxfsでは実データのinodeはホストOSのファイルシステムが見てるので、特にCRUDな操作を必要としない様子

### tmpfsの実装

tmpfs の [shmem_opes](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2488) で実装されているフィールドは下記の通り 

 * .alloc_inode [#](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2377), .destroy_inode
   * kmem_cache_alloc, kmem_cache_free で shmem_inode_info のメモリを割当/解放
      * shmem_inode_info の .vfs_inode フィールドを `struct inode` として返す
   * RAMベースの場合、自前でメモリ抱えて inode を返さないといけないのかな?
 * .statfs [#](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1780)
   * statfs(2) のデータを `struct kstatfs` に埋めて返す
   * ブロックサイズ、空き/使用済みブロック、空き/使用済みinode数 などを入れる 
 * .remount_fs [#](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2237)
   * remount の際に呼ばれてそう。マウントオプションのパースは自分で頑張る必要がある
 * .show_options [#](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2279)
   * ファイルシステム固有のオプションを表示する、とのこと
   * seq_printf で任意の文字列をユーザランドに渡せる
 * .delete_inode 
   * ___メモリ上にあるVFSのinodeとディスク上のデータ、メタデータを削除します___
     * truncate?の場合は inode についた pages を truncate_inode_pages でページキャッシュから解放している
     * shmem_free_inode で 空きinode数をインクリメント
     * その後 clear_inode する。 super_operations の s_op が定義されていれば 呼び出す様子
 * .drop_inode
 * .put_user [#](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2299)
   * sb->s_fs_info を kfree してるだけ。任意の操作を入れといたらいいのかな?

__memo__

 * backing store が ブロックデバイスでなければ .dirty_inode, .write_inode, .write_super, は実装しなくてよい
    * メモリ上のデータがdirtyでもブロックデバイスのデータと同期する必要がないから
 * 2.6.25 未満では .read_inode の実装が必要

## register_file_system したら次はマウントする

vfs_kern_mount でマウントできる

```
struct vfsmount vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
```

 * MS_NOSUER フラグ
   * カーネル内部でマウントするものでユーザランドからマウントするもんじゃないことを指定 [#](http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/2024.html)

 * magic
 * ブロックサイズ
 * super_ops
 * root ディレクトリの初期化
  * dentry
  * inode

## ファイルシステムを作るにあたって実装が必要なんだろうあれこれ

 * file_system_type
   * super_operations
 * fill_super()
 * rootディレクトリのinode
      * [iget_locked](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32;a=m68k#L1067) で VFS inode 0番を確保
   * backing_dev_info
   * inode_operations
   * dir_inode_operations
   * address_space_operations ... ページの読み書き
   * file_operations ... VFSのインタフェースを実装 (read,write,...)
   * vm_operations ... 仮想メモリ用???
   
# カーネルモジュールtips

 * ライセンス表記の MODULE_LICENSE を入れておかないと insmod 時に warning がコンソールに出る
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x279.html
 * __init, __exit のアノテーションをつけておくと、実行後メモリが解放されてエコ 
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x245.html
 * CentOS6 では Development Tools と kernel-devel を入れればビルドできる
   
Makefileのひな形

```
obj-m := sample.oKDIR := /lib/modules/$(shell uname -r)/buildPWD := $(shell pwd)default:	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules```
 * kmem_cache [#](http://www.ibm.com/developerworks/jp/linux/library/l-linux-slab-allocator/)
   * kmem_cache_create であらかじめ登録しておく必要ある
   * init_once ってなんだ???   
```
[vagrant@vagrant-centos65 vagrant]$ sudo mount -t nukofs nukofs /tmp/hoge
mount: Cannot allocate memory
```
   
   
----


```
int nukofs_get_sb(struct file_system_type *fs_type,	int flags, const char *dev_name, void *data, struct vfsmount *mnt){	return get_sb_nodev(fs_type, flags, data, ramfs_fill_super, mnt);}
```