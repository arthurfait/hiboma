# ファイルシステムの実装

### 注意書き

 * 筆者の自習、教育的な用途を目的とした文章です
 * カーネルのバージョンは 2.6.32 ベースで記述しています
 * バニラカーネルのソースを掲載したページへのリンクを貼っているが、CentOSのカーネルはパッチが当たっているので、内容が全然一致しない場合があります
 * backing store を RAM にしたファイルシステムを念頭にしていて、ブロックデバイスのことは考えていません
   * ブロックデバイスベースのファイルシステムは複雑ぽいので、tmpfs と VirtualBox の vboxsf を参考に読み解いていく
   * 追記: tmpfs よりも ramfs の方が素朴な実装なようだ
 * 単語の定義を明確
   * _割り当て_ と書いた場合は、カーネルのメモリ管理APIで実メモリを確保していることを指すようにします (破棄はその逆)
   * _初期化_ と書いた場合は、メモリ割り当てされた構造体の未初期化のフィールドを初期化することを指すようにします
   * _実装_ と書いた場合は、モジュール作成者が任意のコードを書く必要があることを指すようにします
 * [https://github.com/hiboma/nukofs](https://github.com/hiboma/nukofs) に学習用の実装を残しています

## カーネルモジュールとして実装

Linuxのファイルシステムはカーネルモジュールとして実装できます

## モジュールの modules_init で register_filesystem を呼びファイルシステムを登録する
 
俺俺のファイルシステムを登録するにあたって [struct file_system_type](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1745) を定義する

 * カーネルモジュールの modules_initマクロに定義した関数内で [register_filesystem](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L56) で登録したらよい
 * 削除するときは  modules_exitsマクロに定義した関数内で [unregister_filesystem](http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.32#L90) を呼べばよい
 
register_filesystem はファイルシステムのリストに繋げるだけで、後述する .get_sb, .kill_sb らへんの super_block の操作は何も関係ない様子
 
## struct file_system_type の定義

ファイルシステム名の登録( _/proc/filesystems_ で参照できる ) とsuper_block のコンストラクタ/デストラクタを実装するのが目的

 * struct fils_system_type の .get_sb と .kill_sb フィールドの実装が必要
   * ひな形として流用できる関数が用意しされているので利用する
 * .get_sb 
   * [get_sb_nodev](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L855) をラップすればよい
   * デバイスを持たないファイルシステムで superblock を取得するための関数 [#](http://filesystem.g.hatena.ne.jp/n314/20080325/1206426881)
    * get_sb_nodev の中で [sget](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L338) が superblock *sb のメモリを割り当ててくれる
       * [alloc_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L54) で `kzalloc(sizeof(struct super_block),  GFP_USER);` で割当
    * fill_super関数ポインタを実装して superblock のフィールドを初期化する必要がある
 * kill_sb 
   * kill_litter_super を使えばよい

__misc__

 * .get_sb フィールドは 2.6.39 まで。それ以降は .mount になる (vboxfsを参照)
   * get_sb_nodev が変わり mount_nodev になる
 * [kill_litter_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L703) は [kill_anon_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L689) のラッパーで[d_genocide](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L2176) を呼ぶ
   * d_genocide は root dentry から辿って全てのサブディレクトリ以下の dentry の参照カウントをデクリメントする
      * デクリメントするだけで dentry の破棄はしないぽい
      * kill_anon_super -> [generic_shutdown_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L693) で [shrink_dcache_for_umount](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L302) を呼んで dentry のキャッシュを破棄する
   * kill_anon_super の ___anon___ は super_block と結びついた block device が無いことを指すのだろう (anonymouse page 的な)

## struct superblock の初期化 fill_super の役割

 * ファイルシステムの superblock と、ファイルシステムの root ディレクトリとなる VFS inode/dentry の割当て、初期化をする必要がある
 * fill_superの型をもつ関数ポインタを実装して get_sb_nodev に渡す形式
   * vboxsf は sf_read_super_auxで実装している 
   * tmpfs は [shmem_fill_super](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2305) で実装している

なおここでの __inode__ はカーネルのメモリ上で扱われるVFSの `struct inode` のことで、backing store の inode 情報のことではない。backing store の inode 情報を VFSの `struct inode` にマップするのはまた別の話

### fill_super の詳細

```
(int *fill_super)(struct super_block *sb, void *data, int silent)
```

`struct super_block *sb` は [get_sb_nodev](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L855) の中で [sget](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L338) -> [alloc_super](http://lxr.free-electrons.com/source/fs/super.c?v=2.6.32#L54 )で割り当てられたもので、下記の各種フィールドが初期化されていない

 * ブロックサイズ 
   * tmpfs は PAGE_CACHE_SIZE = PAGE_SIZE で指定されている
   * vboxsf は 1024 
 * ブロックサイズをビット値で表した数値 (つまりブロックサイズは2の倍数である必要がある) 
   * tmpfs は PAGE_CACHE_SHIFT = PAGE_SHIFT = 12 (4096) で指定されている
   * vboxsf は未定義
 * マジックナンバー
 * 最大ファイルサイズ
 * super_operations
   * vboxfs は sf_super_ops
   * tmpfs は [shmem_ops](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2488)
 * root になる dentry 
  * rootディレクトリの inode を作り、さらに [d_alloc_root](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L1085) で root dentry を割り当てる必要がある
    * tmpfs の場合 [shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541) の [new_inode](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32#L655) から inode を作る
       * [alloc_inode](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32#L212) で `kmem_cache_alloc(inode_cachep, GFP_KERNEL);` することで inode が割り当てされる
       * shmem_get_inode は root dentry 用以外の inode も割り当てできるように汎用的になっている
    * vboxsf の場合 `iget_locked(sb, 0)` で 0番の inode を作る
 * ctime, mtime, atime の粒度?
 
全てのフィールドを明示的に初期化しなくてもよい様子

#### ramfs は tmpfs と似ているが下記の違いがある

 * [save_mount_options](http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.32#L687) で mount(2)のオプション (void *data) を kstrdup する
    * [generic_show_options](http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.32#L664) を使いたい場合は save_mount_options をあらかじめ呼んで置く必要がある、とコメントがついてる
    * generic_show_options は .show_options のコールバック
 * [ramfs_parse_options](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L184) でマウントオプションのパース。
    * 文字列処理の参考になる
 * 実装のコードはほぼおんなじだけど、__ramfs__ と __rootfs__ と二つのファイルシステムを提供している
   * rootfs の場合は マウントのフラグに MS_NOUSER を足している。ユーザ空間からの mount を許可しない fs なのだった
   * ramfs はユーザ空間から普通にマウントできるやつ

__misc__

 * get_sb_nodev 以外にも [get_sb_pseudo](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L207) などある
   * ファイルシステムのバックエンドに応じて呼び出せばよい?

## ファイルシステムの rootディレクトリとなる VFS inode の初期化

 * root ディレクトリのVFS inode を割り当て、パーミッション, uid/gid, 各種operations を初期化する必要がある
 * ブロックデバイスベースのファイルシステムの場合は、デバイスからrootディレクトリのinode情報を読み取って適宜初期化する必要がある
 * RAMベースの場合は、ファイルシステムの都合で適当に初期化しておけば良い
   * tmpfsの[shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541)を見るのがよい
   * ramfsの[ramfs_get_inode](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L54)はもっとシンプル
     * simple_dir_operations とは?
     * [mapping_set_gfp_mask](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L64) とは?
       * `mapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);`
       * address_space の メモリ割り当てを Highメモリから取る?
       * refs http://seijinoblog.blogspot.jp/2012/03/linux_29.html
     * [mapping_set_unevictable](http://lxr.free-electrons.com/source/include/linux/pagemap.h?v=2.6.32#L38) とは?
       * [Unevictable LRU](https://www.kernel.org/doc/Documentation/vm/unevictable-lru.txt) を読んで理解する
       * アドレス空間全体を AS_UNEVICTABLE

```
Unevictable リストとは文字どおり、強制回収できないリストを表す。この機構は比較的最近実装された
もので、64 bit 環境で 100GB を越える大容量な RAM を搭載した環境におけるページフレーム回収コス
トを減らす目的で導入されている。最新のカーネルドキュメント (*2) によれば、unevictable リストに
属するページは、次の 3 種類のページになる (らしい)。

　・ramfs が所有するページ
　・共有メモリロックのメモリリージョンにマッピングされているページ
　・VM_LOCKED フラグがセットされたメモリリージョンにマッピングされているページ
```
 * refs [lkml でお勉強 (その1-2)](http://dev.ariel-networks.com/Members/ohyama/lkml-304a52c95f37-305d306e1-2/)

 
### struct inode 各種フィールド
 
 * i_mode 
    * パーミッションはファイルシステムのポリシーで任意
    * i_mode に S_IFDIR 足しとかないと mount(2) で ENOTDIR `Not a directory` 返すので注意
 * uid,gid
 * atime, mtime, ctime
    * CURRENT_TIMEマクロを使うと現在時刻で初期化できる
 * i_mapping->backing_dev_info 
 * i_mapping->a_ops
 * inode_operations
    * ファイルとディレクトリとで実装内容が違う
 * ファイルの場合は
   * file_operations
 * ディレクトリの場合は
   * dir_operations
 * nlink リンク数
 * ブロック数
   * backing store が RAM の場合、適当な数値を入れてハックする必要があるぽい (tmpfsの例)

__misc__

 * vboxsf はホストOSの共有フォルダの情報を sf_stat で調べて情報を取り、sf_init_inode で適宜埋める様子
   * ホストOSはUNIX系OSとは限らないので汎用的な作りになってる
 * tmpfs の場合 [shmem_get_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1541) で初期化している   
 * その他 dquot_operations, quotactl_ops, export_operations (nfs) は必要なら適宜初期化したらよい様子
 * tmpfs では俺俺の [struct shmem_sb_info](http://lxr.free-electrons.com/source/include/linux/shmem_fs.h?v=2.6.32#L24) を sb->s_fs_info に入れている
   * s_fs_info は `void * s_fs_info /* Filesystem private info */` とあり、ファイルシステム固有の俺俺データを入れとく用途
   * tmpfsでは各種制限が設けられていて、その閾値をぶっ込んでいる
    * [shmem_default_max_blocks](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L110) で ブロックの最大数を [totalram_pages](http://wiki.bit-hive.com/north/pg/%A5%C8%A1%BC%A5%BF%A5%EB%A5%E1%A5%E2%A5%EA)/2 としている
    * [shmem_default_max_inodes](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L115) で inodeの最大数を min(totalram_pages - totalhigh_pages, totalram_pages / 2); にしている
 * tmpfs として利用する場合は MS_NOUSERフラグが落ちてる
 
## struct backing_dev_info とは?

* アドレス空間の背後にある周辺機器(peripheral device)を __Backing store__ と呼ぶ (refs Linux Kernel Architecture p.957 )
* ふつーはブロックデバイスだけど、もちろんRAMベースもある。

backing store のメタデータを入れておくのが [struct backing_dev_info](http://lxr.free-electrons.com/source/include/linux/backing-dev.h?v=2.6.32#L60)

 * [bdi_init](http://lxr.free-electrons.com/source/mm/backing-dev.c?v=2.6.32#L651 ) で登録
 * [bdi_destroy](http://lxr.free-electrons.com/source/mm/backing-dev.c?v=2.6.32#L693) で解除

### struct backing_dev_info のフィールド

 * ra_pages 
   * 先読みするページの最大数を指定(readahead pages)
   * RAMだと先読みいらんし、ブロックデバイスだけで有効かな
 * capabilities 
   * ページを backing store と同期(write back)する際のポリシーなどを指定
   * ブロックデバイスだと必要だけど RAM だといらん 
   * mmap できるかなども指定するぽい   
   * [各種フラグ](http://lxr.free-electrons.com/source/include/linux/backing-dev.h?v=2.6.32#L200)
     * BDI_CAP_NO_ACCT_AND_WRITEBACK
     * BDI_CAP_NO_ACCT_DIRTY RAM backing store だとページが dirty かどうかの判定いらん
       * これらのフラグがどうやって利用されてるかが謎。
 * dev 
   * struct device 入れておく。 RAM backing store だと null 入れておkらしい
   
他にもいろいろ面白そうなフィールドあるけど、ブロックデバイスじゃないと関係なさそうな空気   
   
## [struct super_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1562) の実装

RAMベースだと全てを実装する必要は無い。

### vboxsfの実装

2.6.32用のvboxsfで実装されるフィールドは下記の4つ

 * .clear_inode
   * inode->private から sf_inode_info を取り出して kfree
 * .put_user 
   * umount(2) して super_blockを解放する時に呼ぶ?
   * super_block から sf_glob_info を取り出して、backing_dev を bdi_destroy してる
   * vboxCallUnmapFolder でホストOSのフォルダとのマップを解除
 * .statfs
 * .remount_fs 
 
vboxsfでは実データのinodeはホストOSのファイルシステムが見てるので、特にCRUDな操作を必要としない様子。vboxsfがゲストOSとホストOSの間を透過的にするレイヤになる

### tmpfsの実装

tmpfs の [shmem_ops](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2488) で実装されているフィールドは下記の通り 

 * [.alloc_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2377), .destroy_inode
   * kmem_cache_alloc, kmem_cache_free で shmem_inode_info のメモリを割当/解放
      * shmem_inode_info の .vfs_inode フィールドを `struct inode` として返す
   * RAMベースの場合、自前でメモリ抱えて inode を返さないといけないのかな?
 * [.statfs](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1780)
   * statfs(2) のデータを `struct kstatfs` に埋めて返す
   * ブロックサイズ、空き/使用済みブロック、空き/使用済みinode数 などを入れる 
 * [.remount_fs](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2237)
   * remount の際に呼ばれてそう。マウントオプションのパースは自分で頑張る必要がある
 * [.show_options](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2279)
   * ファイルシステム固有のオプションを表示する、とのこと
   * seq_printf で任意の文字列をユーザランドに渡せる
 * .delete_inode 
   * ___メモリ上にあるVFSのinodeとディスク上のデータ、メタデータを削除します___
     * truncate?の場合は inode についた pages を truncate_inode_pages でページキャッシュから解放している
     * shmem_free_inode で 空きinode数をインクリメント
     * その後 clear_inode する。 super_operations の s_op が定義されていれば 呼び出す様子
 * .drop_inode
 * [.put_user](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2299)
   * sb->s_fs_info を kfree してるだけ。任意の操作を入れといたらいいのかな?

__memo__

 * backing store が ブロックデバイスでなければ .dirty_inode, .write_inode, .write_super, は実装しなくてよい
    * メモリ上のデータがdirtyでもブロックデバイスのデータと同期する必要がないから
 * 2.6.25 未満では .read_inode の実装が必要

## register_file_system したら次はマウントする

ファイルシステムを登録したら vfs_kern_mount でマウントできる

```
struct vfsmount vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
```

vfs_kern_mount はカーネル内でマウントするAPIで、ユーザランドから mount(2) してもよい。


 * MS_NOUSER フラグ
   * カーネル内部でマウントするものでユーザランドからマウントするもんじゃないことを指定 [#](http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-01/2024.html)
   * MS_NOUSER をつけておいて、vfs_kern_mount でカーネルモジュール内でマウントするファイルシステムがある (pipefs?)

 * magic
 * ブロックサイズ
 * super_ops
 * root ディレクトリの初期化
  * dentry
  * inode

## [struct inode_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1518) の実装

nukofs を mount したディレクトリに通常ファイルを作成したいので inode_operations の必要なフィールドを実装する

### .lookup

```c
/**
 * This is called when vfs failed to locate dentry in the cache. The
 * job of this function is to allocate inode and link it to dentry.
 * [dentry] contains the name to be looked in the [parent] directory.
 * Failure to locate the name is not a "hard" error, in this case NULL
 * inode is added to [dentry] and vfs should proceed trying to create
 * the entry via other means. NULL(or "positive" pointer) ought to be
 * returned in case of success and "negative" pointer on error
 */
static struct dentry *sf_lookup(struct inode *parent, struct dentry *dentry
```

 * vboxsf の説明には sf_lookup VFS が dentry を cache miss した際に呼ばれる。inode を割り当て、dentry と link する
 * [simple_lookup](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L47) が用意されているので使える

```
ディレクトリ .dir を検索します。dエントリオブジェクト dentry に含まれるファイル名に対応するinodeを見つけるためです
```

### VFS inode の割り当て

 * tmpfs の [shmem_mknod](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1805), [ramfs](http://lxr.free-electrons.com/source/fs/ramfs/inode.c?v=2.6.32#L95) の ramfs_mknod ともにファイル/ディレクトリ作成に .mknod のコールバックを流用している
   * .mknod は [mknod(2)](http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.32#L2094) で呼び出されるコールバック
     * vfs の呼び出しを見ると、通常ファイルでは vfs_create, その他では vfs_mknod を呼び出している
     * 通常ファイルを作るには .create を実装しておかないといけないのね
   * VFS inode は 汎用API ( shmem_get_inode, ramfs_get_inode ) で割り当てている
   * VFS inode を [d_instantiate](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L991) と [dget](http://lxr.free-electrons.com/source/include/linux/dcache.h?v=2.6.32#L320) している
     * d_instantiate は VFS inode のデータで dentry を初期化? する
     * dget は参照カウントをインクリメントする = dentry cache との関係?

 * コンストラクタ的なコールバックは自前で実装が必要ぽいけど、デストラクタっぽいのは simple_*** みたいなので事足りるのかな?
   * fs/libfs.c に `Library for filesystems writers` とコメント有るので、ファルシステム作成を支援するライブラリぽい

### .create

 * .create
   * .create は `dentry に対応する通常ファイル用に、新しいディスクinodeを作成します`

### umount(2) をする際に Oops! した [#4](https://github.com/hiboma/nukofs/issues/4)

.create, .mknod を実装して、通常ファイルを作成して umount したら oops

![](https://f.cloud.github.com/assets/172456/1930814/a19ef548-7eb4-11e3-8346-525a55b40c00.png)


 * umount すると [shrink_dcache_for_umount](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L715) で superblock にぶら下がった dentry を破棄する
 * [shrink_dcache_for_umount_subtree](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L619)
   * .kill_sb を kill_anon_super から kill_litter_super にしたら解決した
     * vboxsf は kill_anon_super だな
   * umount する前に dentry を掃除しておかないとだめぽい
     * `atomic_read(&dentry->d_count) != 0` を満たさないと BUG() を出す [refs](http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.32#L658)

### unlink(2) が Operation not permitted [#6](https://github.com/hiboma/nukofs/issues/6)

[vfs_unlink](http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.32#L2277) で i_op->unlink が NULL だと -EPERM を返す

```c
int vfs_unlink(struct inode *dir, struct dentry *dentry)
{
	int error = may_delete(dir, dentry, 0);

	if (error)
		return error;

	if (!dir->i_op->unlink)
		return -EPERM;
```

 * ディレクトリの inode_operations に `.unlink = simple_unlink` を実装して解決した
    * ramfs は [simple_unlink](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L287)
      * drop_nlink と dput が肝
      * ハードリンクされている場合は unlink(2) しても inode は残るので `inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;` している
        * ディレクトリの c_time, mtime が更新されてるのがポイント
    * tmpfs は [shmem_unlink](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1881)
       * [shmem_free_inode](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L258) で superblock の空きinode数をインクリメントしているのが simple_unlink と違う
       * `sbinfo->free_inodes` は tmpfs の inode数上限を管理するための数値
    * vbosf は sf_unlink -> sf_unlink_aux でホストOSとやり取り。
      * ホストOS のinodeとゲストの VFS inode, dentry がどう扱われてるかを覗ける

__misc__

 * ramfs_mknod のコメントに `/* SMP-safe */` とある

### mkdir(2) が Operation not permitted [#8](https://github.com/hiboma/nukofs/issues/8)

.mkdir, .rmdir を実装する必要がある

 * .mkdir は自前で頑張る。
 * .rmdir は [simple_rmdir](http://lxr.free-electrons.com/ident?v=2.6.32&i=simple_rmdir) で代用できた
   * rmdir -> do_rmdir -> vfs_rmdir -> .rmdir
   * `int vfs_rmdir(struct inode *dir, struct dentry *dentry)` *dir は親ディレクトリかな。dentry は rmdir したいディレクトリのdentry
     * `d_mountpoint(dentry)` で マウントされているかいなかを見る
   * simple_rmdir は [simple_unlink](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L287) 呼び出している
   * 通常ファイルと同じように unlink するけど、親ディレクトリの inode->i_nlink(リンク数) を drop_nlink デクリメントするのが違う

#### tmpfs

simple_unlink を呼ぶ順番が前後してるだけで、 simple_rmdir とほぼ同じ

 * [shmem_rmdir](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1895)
   * [simple_empty](http://lxr.free-electrons.com/source/fs/libfs.c?v=2.6.32#L272) でディレクトリが空かどうか(dentryのサブディレクトリを走査) みる
   * [shmem_unlink](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L1881) をラップしている

#### chown(2) の実装

特に何も実装していないのに chown(2) が成功した why?

 * VFS inode のフィールドを変更するだけなら特になんもいらん?
 * chown -> sys_fchownat -> chown_common -> notify_change -> [inode_setattr](http://lxr.free-electrons.com/source/fs/attr.c?v=2.6.32#L108) ( -> generic_setattr)
   * バニラカーネルだと inode_setattr, CentOS6カーネルだと generic_setattr で VFS inode のフィールドを変更している
 * dirty な inode をブロックデバイスに書き出すのはまた別 -> super_operations の .dirty_inode かな?
 * chown は sys_fchownat をラップしている

RAMベースのファイルシステムの場合は VFS inode だけを扱えばいいので、特に実装がいらんてことになる

## [struct file_operations](http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1489)

```
ファイルの読み取りや下記k未などの操作を行う、ファイルシステムごとに固有のファイル操作(file operation)関数群があります
```

 * inode->i_fop メンバ
 * open(2) ないと呼べないよね? ( `struct file` を確保しているのが前提)

### write(2) が Invalid argument [#11](https://github.com/hiboma/nukofs/issues/11)

 * [sys_write](http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.32#L389) -> [vfs_write](http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.32#L332)
   * file_operations の .write または aio_write を実装しておかないと EINVAL を返す

```c
ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
	ssize_t ret;

	if (!(file->f_mode & FMODE_WRITE))
		return -EBADF;
	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
		return -EINVAL;
	if (unlikely(!access_ok(VERIFY_READ, buf, count)))
		return -EFAULT;

	ret = rw_verify_area(WRITE, file, pos, count);
	if (ret >= 0) {
		count = ret;
		if (file->f_op->write)
			ret = file->f_op->write(file, buf, count, pos);
		else
			ret = do_sync_write(file, buf, count, pos);
		if (ret > 0) {
			fsnotify_modify(file->f_path.dentry);
			add_wchar(current, ret);
		}
		inc_syscw(current);
	}

	return ret;
}
```

ということで `struct file_operations` の .write, .aio_write を実装しよう

#### ramfs

 * [do_sync_write](http://lxr.free-electrons.com/source/fs/ramfs/file-mmu.c?v=2.6.32#L40) を使ってる
   * file_->f_op->aio_write 

#### tmpfs

 * [do_sync_write](http://lxr.free-electrons.com/source/mm/shmem.c?v=2.6.32#L2427) を使ってる

## ファイルシステムを作るにあたって実装が必要なんだろうまとめ

 * struct file_system_type
   * super_operations
 * fill_super()
 * rootディレクトリの VFS inode
      * [iget_locked](http://lxr.free-electrons.com/source/fs/inode.c?v=2.6.32;a=m68k#L1067) で VFS inode 0番を割り当て
   * struct backing_dev_info
   * struct inode_operations
   * dir_inode_operations
   * address_space_operations ... ページの読み書き
   * file_operations ... VFSのインタフェースを実装 (read,write,...)
   * vm_operations ... 仮想メモリ用???

## memo

### /proc/filesystems の nodev の有無

`proc/filesystems` を cat すると nodev がついてるファイルシステムとそうでないのがある

```
[vagrant@vagrant-centos65 ~]$ cat /proc/filesystems 
nodev   sysfs
nodev   rootfs
nodev   bdev
nodev   proc
...
        iso9660
nodev   pstore
nodev   mqueue
        ext4
nodev   vboxsf
nodev   nukofs
```

 * file_systems_proc_show がコールバックとして定義されている
   * `struct file_system_type` の fs_flags に FS_REQUIRES_DEV が立っているかどうかの違いらしい
   * `この種類の全てのファイルシステムは物理ディスクデバイス上に存在する必要がある`
   * FS_REQUIRES_DEV が立ってないファイルシステムは NFS で export もできない?

```c
static int filesystems_proc_show(struct seq_file *m, void *v)
{
	struct file_system_type * tmp;

	read_lock(&file_systems_lock);
	tmp = file_systems;
	while (tmp) {
		seq_printf(m, "%s\t%s\n",
			(tmp->fs_flags & FS_REQUIRES_DEV) ? "" : "nodev",
			tmp->name);
		tmp = tmp->next;
	}
	read_unlock(&file_systems_lock);
	return 0;
}
```

### Pseudo-Filesystems
   * 擬似ファイルシステム ユーザランドから mount することを許可しない (MS_NOUSER) ファイルシステム
   * sockfs, pipefs, bdev ..
   * .get_sb の flags | MS_NOUSER としておくと、mount 時にこんなんでる

```
mount: wrong fs type, bad option, bad superblock on nukofs,
       missing codepage or helper program, or other error
       (for several filesystems (e.g. nfs, cifs) you might
       need a /sbin/mount.<type> helper program)
       In some cases useful info is found in syslog - try
       dmesg | tail  or so
```   
   
#### TODO   
   
 * open して close してファイルを追加するにはどうしたら?
 * mkdirしたらどうやってinodeを管理すればよい?
   * dentry化しておけばok?
   
# カーネルモジュール tips

 * ライセンス表記の MODULE_LICENSE を入れておかないと insmod 時に warning がコンソールに出る
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x279.html
 * `__init`, `__exit` のアノテーションをつけておくと、モジュールをロード(アンロード)して関数実行後メモリが解放されてエコらしい
   * http://www.tldp.org/LDP/lkmpg/2.6/html/x245.html
 * CentOS6 では Development Tools と kernel-devel を入れればビルドできる

 * Makefileのひな形

```
obj-m := sample.oKDIR := /lib/modules/$(shell uname -r)/buildPWD := $(shell pwd)default:	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules```
 * [kmem_cache](http://www.ibm.com/developerworks/jp/linux/library/l-linux-slab-allocator/) API 
   * kmem_cache_create であらかじめ登録しておく必要ある
   * init_once ってなんだ???
