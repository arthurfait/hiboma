# struct page のゼロ初期化

clear_page, clear_highpage を見ればよい

## clear_page

 * 高速化を計るためにアーキテクチャ依存の命令を呼び出す
 * アーキテクチャ依存しないでも書けるけど、CPU独自の命令の方が速度でる と Linux Kernel Architecture 本にもある (P.221)

### clear_page + MMX

MMX 命令を使って初期化する実装

```c
#ifdef CONFIG_X86_USE_3DNOW
#include <asm/mmx.h>

static inline void clear_page(void *page)
{
	mmx_clear_page(page);
}
```

プロセスコンテキストと割り込みコンテキストとで2種類ある

```c
void mmx_clear_page(void *page)
{
	if (unlikely(in_interrupt()))
		slow_zero_page(page);
	else
		fast_clear_page(page);
}
EXPORT_SYMBOL(mmx_clear_page);
```

```c
/*
 * Favour MMX for page clear and copy:
 */
static void slow_zero_page(void *page)
{
	int d0, d1;

	__asm__ __volatile__(
		"cld\n\t"            // DFフラグをクリアする http://softwaretechnique.jp/OS_Development/Tips/IA32_Instructions/CLD.html
		"rep ; stosl"        // stos +l 命令 で 1024 回?

			: "=&c" (d0), "=&D" (d1)
			:"a" (0), "1" (page), "0" (1024)
			:"memory");
}
```

```c
/*
 *	Generic MMX implementation without K7 specific streaming
 */
static void fast_clear_page(void *page)
{
	int i;

	kernel_fpu_begin();

	__asm__ __volatile__ (
		"  pxor %%mm0, %%mm0\n" : : // 排他的論理和演算を行います
                                    // %mm0 レジスタを 0 にしているのかな?
	);

	for (i = 0; i < 4096/128; i++) {
		__asm__ __volatile__ (
		"  movq %%mm0, (%0)\n"     // http://softwaretechnique.jp/OS_Development/Tips/IA32_MMX_Instructions/MOVQ.html
		"  movq %%mm0, 8(%0)\n"    // mm0 レジスタからクワッドワードのデータを転送する
		"  movq %%mm0, 16(%0)\n"
		"  movq %%mm0, 24(%0)\n"
		"  movq %%mm0, 32(%0)\n"
		"  movq %%mm0, 40(%0)\n"
		"  movq %%mm0, 48(%0)\n"
		"  movq %%mm0, 56(%0)\n"
		"  movq %%mm0, 64(%0)\n"
		"  movq %%mm0, 72(%0)\n"
		"  movq %%mm0, 80(%0)\n"
		"  movq %%mm0, 88(%0)\n"
		"  movq %%mm0, 96(%0)\n"
		"  movq %%mm0, 104(%0)\n"
		"  movq %%mm0, 112(%0)\n"
		"  movq %%mm0, 120(%0)\n"
			: : "r" (page) : "memory");
		page += 128;
	}

	kernel_fpu_end();
}
```