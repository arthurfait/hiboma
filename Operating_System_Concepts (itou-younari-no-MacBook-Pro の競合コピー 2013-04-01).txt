* [本] Operating System Conectps

## 5. Memory Management

> Memory is a large array of words or bytes, each with its own address

 * 今日 `load` を意識してコードを書いてる場面が無いなと思った
 
## 5.3 Resident Monitor 

 * resident monitor (= kernel) のメモリはアドレスの低位置に配置するものが多い
   * 割り込みベクタが低位置にするものが多いから? 保護するのにちょうどいいんだろうか
     * 8006 は割り込みベクタをメモリの 0 ~ 1K の領域にセットする (「はじめて読む8086」)

 * `fence address`
   * プログラム ( not プロセス) のアドレスの範囲をハードウェアで限定する仕組み
   * 特権つきの命令でレジスタに登録しておく

## 5.3.2 Relocation

 * relocatable, 再配置可能なコード
   * コード内のアドレスが相対アドレスで管理される。コンパイラの仕事
   * `binding` 実メモリに配置すること

 * PDP-11 はユーザーモードのコードは高位置のアドレスに配置 => 低い方 (fence) に向かって伸びる

 * `relocation register`
   * `dynamic relocation`

> Notice that the user never sees the real physical addresses

 * 物理的なアドレスを意識しない
 * 物理的な特性に縛られず、論理的な特性にのみに従ってプログラムを記述できる
 
## 5.4 Swapping

 * `Backing Store`
   * swap device のことじゃろう
   * 容量が大きいけど転送速度が遅いストレージに swap 領域を確保するという考え方は共通

## 5.5 Fixed Partitions

## 5.5.1 Proctetion Hardware

 * プログラムのアドレスの上限 <=> 下限を制限するレジスタ
   * `Bounds registers` 上限のアドレスを下限のアドレスを絶対値で指定
     * 静的な再配置
   * `Base and limit registers` 基点となるアドレス+リミット値で指定
     * 動的な再配置
     * x86のセグメントの考え方もこれ segment base, segment limit

## 5.7 paging

 * 物理メモリは `frames` と呼ぶブロックに分解される
 * 論理メモリは `pages`  に分解される
   * pages => page table => frames でアドレスの変換をする
   
ページングはハードウェア依存の仕様。 (design of ... にも同様の記述がある)

 * `paging itself is a form of dynamic relocation`
   * ページングの考え方は動的再配置そのもの
   
## 5.7.6 Two Views of Memory

 * ページング
   * 論理アドレスと物理アドレスの分離。

## 5.8 Segmentation

 * セグメント機構。x86のやつ
   * 名前で参照する
   * 可変長の領域
     * 名前と長さをもつ領域、として抽象化

 * `segment base` , `segment limit`
  * 8006 だと セグメントベース, オフセットアドレス と呼ぶ
 * `segment table`
  * base と limit のペアの配列
  * メモリかレジスタ上に配置しておく
  * PDP-11/45
    * 8個のセグメントレジスタ
      * 3bitの segment number (base), 13bit の segment offset (limit) => 8K の領域
  * 8086
    * CS Code Segment
    * DS Data Segment
    * ES Extra Segment
    * SS Stack Segment
      * オフセットアドレスが16bit = 1セグメントで64KB

## 5.8.4 Protection and Sharing

 * `non-self-modifying`
   * コードセグメントは不変であるようにする => 複数プロセスで共有可能
   * TODO: コードセグメントを複数プロセスで共有した場合、共有が解除されるまで上書きができないのでは?
 * セグメント機構は外部断片化( `external fragmentation` )する
   * ページングと違ってセグメントの領域が可変長であるため。
   * 領域を確保するために `compaction` が必要

## 6. Virtual Memory

 * `demand paging`

## 6.1 Overlays

 * 仮想メモリの仕組みがないと、プロセスの論理アドレス分のメモリを常駐させておく必要がある
   * データ/テキストセグメントで参照/実行されない箇所のコードをメモリに置いておくのは無駄
 * `overlay`
   * MSXのフロッピーディスクの交換?
 * `dynamic loading`
   * 動的ロード、プラグイン、遅延読み込み、実行時ロード

どちらもユーザランド側で実装する類いのもの。OS側であれこれするもんじゃないらしい。

## 6.2 Demand Paging

 * 
