* [c][kernel][本] UNIX 4.3BSDの設計と実装

## VAX

 * 0 kernel, 1, 2, 3 user の特権レベル

## 3 カーネルサービス

 * top half
   * プロセスコンテキスト
 * bottom half
   * 割り込みコンテキスト
   * 非同期
   * スケジュールされない
   
### カーネル入り口

OS,アーキテクチャによる違いはあるが 設計の骨組みとして共通するのは

 * ユーザモード/カーネルモードの切り替え
 * レジスタの退避/復帰
 * ハンドラの実行が要点
 
のあたり。

## システムプロセス

 * swapperプロセス
   * PID = 0 Bach本とだいたい同じ記述

## 3.2 システムコール

Bach本 6.4.2 に書かれている記述/擬似コードと合致する部分が多い

 * システムコールの一覧
  * /_/c/4.3BSD/srcsys/sys/syscalls.c

 * `return from iterruput` で変える
 * VAX 0番目の汎用レジスタに返り値がはいる。Linuxのx86系と同じ (eax)
 * Cライブラリが errno を操作してエラーを指し示す
   * PDP-11 由来の歴史的な作法らしい。

 * システムコールのシグナル割り込み EINTER について触れられてる
   * setjmp, プログラムカウンタを保存して使っているあたり?
 
### source (machine/trap.c)

割り込みベクタでのディスパッチ => syscall() => システムコール番号でのディスパッチ 
 
  * 割り込みベクタの初期化 (machine/scb.s)
  * 4byteごとにならんどる?

    /* 000 */       STRAY;          IS(machcheck);  IS(kspnotval);  STOP(powfail);
    /* 010 */       KS(privinflt);  KS(xfcflt);     KS(resopflt);   KS(resadflt);
    /* 020 */       KS(protflt);    KS(transflt);   KS(tracep);     KS(bptflt);
    /* 030 */       KS(compatflt);  KS(arithtrap);  STRAY;          STRAY;
    /* 040 */       KS(syscall);    KS(chme);       KS(chms);       KS(chmu);
    /* 050 */       STRAY;          IS(cmrd);       STRAY;          STRAY;
    /* 060 */       IS(wtime);      STRAY;          STRAY;          STRAY;
    /* 070 */       STRAY;          STRAY;          STRAY;          STRAY;
    /* 080 */       STRAY;          STRAY;          KS(astflt);     STRAY;
    /* 090 */       STRAY;          STRAY;          STRAY;          STRAY;
    /* 0a0 */       IS(softclock);  STRAY;          STRAY;          STRAY;
    /* 0b0 */       IS(netintr);    STRAY;          STRAY;          STRAY;
    /* 0c0 */       IS(hardclock);  STRAY;          KS(emulate);    KS(emulateFPD);
    /* 0d0 */       STRAY;          STRAY;          STRAY;          STRAY;
    /* 0e0 */       STRAY;          STRAY;          STRAY;          STRAY;
    /* 0f0 */       IS(consdin);    IS(consdout);   IS(cnrint);     IS(cnxint);
    /* 100 */       IS(nexzvec); STRAY15;           /* ipl 0x14, nexus 0-15 */
    /* 140 */       IS(nexzvec); STRAY15;           /* ipl 0x15, nexus 0-15 */
    /* 180 */       IS(nexzvec); STRAY15;           /* ipl 0x16, nexus 0-15 */
    /* 1c0 */       IS(nexzvec); STRAY15;           /* ipl 0x17, nexus 0-15 */

 * 割り込みハンドラの実装 (machine/locore.s)
 * chmk (CHange Mode to Kernel ) 

    SCBVEC(syscall):
            pushl   $T_SYSCALL 
            mfpr    $USP,-(sp);   
                    calls $0,_syscall;
                    mtpr (sp)+,$USP
            incl    _cnt+V_SYSCALL      // システムコールを呼び出した回数を ++ かな
            addl2   $8,sp                   # pop type, code
            mtpr    $HIGH,$IPL              ## dont go to a higher IPL (GROT)
            rei

 * C実装の syscall が呼び出される。( trap.c )
   * trap(sp, type, code, pc, psl) はページフォルトとかをハンドリングする用
     * 6th では trap で システムコールのディスパッチをしていたけど、4.3BSDでは syscall に移動している

 * syscall は システムコールテーブルの番号をみて関数ポインタでディスパッチする役割
   * ユーザ空間から引数をコピーする、レジスタでエラー通知 などが肝
 
    syscall(sp, type, code, pc, psl)

    // システムコールへの引き数の確認
    if ((i = callp->sy_narg * sizeof (int)) &&
    // ユーザ空間のスタック? からカーネル空間に引数をコピーしている箇所
    (u.u_error = copyin(params, (caddr_t)u.u_arg, (u_int)i)) != 0) {
                                               // コピーがエラった場合
        locr0[R0] = u.u_error;                 // レジスタ0 にエラー番号を入れる
        locr0[PS] |= PSL_C;     /* carry bit */// PSの carry bit を立ててエラーの通知

        (*(callp->sy_call))();                 // 関数ポインタでシステムコール呼び出し
                                               // 引数は u で参照できる
      if (u.u_eosys == NORMALRETURN) {
          // システムコールがエラった場合の番号が u_error に入ってる
          if (u.u_error) {
              locr0[R0] = u.u_error;
              locr0[PS] |= PSL_C; /* carry bit */ // carry bit たてる
          } else {
              locr0[R0] = u.u_r.r_val1;           // レジスタ0 にはシステムコールの返り値をセットしておく
              locr0[R1] = u.u_r.r_val2;           // ? なんだべ
              locr0[PS] &= ~PSL_C;                // carry bit をクリア => システムコール成功の印
          }
      } else if (u.u_eosys == RESTARTSYS)
          pc = opc;                               // プログラムカウンタを戻す?
                                                  // SA_RESTARTでシグナル割り込みされた際の処理ぽいんだけど謎

  * runrun(reschedule)のフラグがたってたら swtch() して優先度高いプロセスに変える

### ユーザランド側の システムコール呼び出し

http://193.166.3.2/pub/unix/4.3bsd/net2/lib/ から拾った

 * VAX

    #ifdef PROF
    #define	ENTRY(x)	.globl _/**/x; .align 2; _/**/x: .word 0; \
    			.data; 1:; .long 0; .text; moval 1b,r0; jsb mcount
    #else
    #define	ENTRY(x)	.globl _/**/x; .align 2; _/**/x: .word 0
    #endif PROF
    #define	SYSCALL(x)	err: jmp cerror; ENTRY(x); chmk $SYS_/**/x; jcs err
    #define	RSYSCALL(x)	SYSCALL(x); ret
    #define	PSEUDO(x,y)	ENTRY(x); chmk $SYS_/**/y; ret
    #define	CALL(x,y)	calls $x, _/**/y
    
    #define	ASMSTR		.asciz

    ENTRY(syscall)
    	movl	4(ap),r0	    # syscall number
    	subl3	$1,(ap)+,(ap)	# one fewer arguments
    	chmk	r0              # CHange Mode to Kernel (カーネルモードに移行する命令らしい
    	jcs	1f
    	ret
    1:
    	jmp	cerror

 * i386

    #include "SYS.h"

    #ifdef PROF
    #define	ENTRY(x)	.globl _/**/x; \
    			.data; 1:; .long 0; .text; .align 2; _/**/x: \
    			movl $1b,%eax; call mcount
    #else
    #define	ENTRY(x)	.globl _/**/x; .text; .align 2; _/**/x: 
    #endif PROF
    #define	SYSCALL(x)	2: jmp cerror; ENTRY(x); lea SYS_/**/x,%eax; LCALL(7,0); jb 2b
    #define	RSYSCALL(x)	SYSCALL(x); ret
    #define	PSEUDO(x,y)	ENTRY(x); lea SYS_/**/y, %eax; ; LCALL(7,0); ret
    #define	CALL(x,y)	call _/**/y; addl $4*x,%esp
    /* gas fucks up offset -- although we don't currently need it, do for BCS */
    #define	LCALL(x,y)	.byte 0x9a ; .long y; .word x
    
    #define	ASMSTR		.asciz
        
    ENTRY(syscall)
    	pop	%ecx	/* rta */
    	pop	%eax	/* syscall number */
    	push	%ecx
    	LCALL(7,0)  // 特別な命令で呼び出さないで、サブルーチン呼び出し???
    	jb	1f
    	ret
    1:
    	jmp	cerror 
        
 
# 4 プロセス管理
 
## ファイルシステム
 
### 7.5 バッファ管理 (bio.c)

 * getblk
   * ブロックに割り当てられるバッファを獲得する
     * 獲得したいバッファが他のプロセスが使用中 (B_BUSY) であれば 待つ
     * バッファが無い場合も待つ

 * bfreelist
   * 複数アルゴリズムで bfreelist を持つ
   * unix 6th だと一個だけ (LRU?

 * bread(dev, blkno, size)
   * 現行の linux だと `struct buffer_head * __bread(struct block_device *bdev, sector_t block, unsigned size)`
   * デバイスドライバを呼び出してバッファを埋める、という意味合いでこの名前を使う
   * bread で獲得しようとしたバッファがロックされている場合は 休止(sleep?) して待つ
     * linux __bread だと TASK_UNINTERRUPTIBLE で待つぽい

バッファの再利用、I/Oの割り込みを待つ場合、自分で sleep に入るってあたりが肝

#### バッファを解放するメソッド 4つ

 * brelse
   * バッファが変更されている状態に対して `dirty` と呼ぶ記述がある
   * bfreelist に B_WANTED を立てておくと wakeup を読んでバッファ解放待ちのプロセスを解放してくれるイベントを立てる

	if (bp->b_flags&B_WANTED)
		wakeup((caddr_t)bp);
	if (bfreelist[0].b_flags&B_WANTED) {
		bfreelist[0].b_flags &= ~B_WANTED;
		wakeup((caddr_t)bfreelist);
	}

     * 6th では 単純に bfreelist の末尾にバッファを戻す
     * 4.3BSDだと b_flags に応じた bfreelist を選択して末尾に戻す
   * linux だと __brelse 参照カウントをatomicに下げるだけ
     * 参照カウントで locked / unlocked を決めている

 * bdwrite ... diry の印をつけるけど、呼び出し時点ではI/Oを発行しない。(`delayed write` の略
   * 遅延書き込み
   * バッファが近い時間のうちに再変更される可能性がある場合、すぐにI/Oを発行しておかないで「溜めて」置いたが効率が良い
   * 実装は B_DELWRI (delay write, B_DONE) フラグたてて brelse 呼んでいるだけ

 * bawrite ... 非同期書き込み
 　* 実装は B_ASYNC をたてて bwrite 呼んでいるだけ

 * bwrite  ... 同期書き込み
   * fdatasync, fsync, O_SYNC ?
   * ブロックデバイスに対して I/O を発行している 

    bdevsw[major(bp->b_dev)].d_strategy)(bp);`
   
   * biowait で sleep する
     * ドライバからの割り込みで wakeup が呼び出されるはず

 * bflush  遅延書き込みバッファをディスクに書き出し
   * 6th だと /etc/update デーモンが 30秒ごとに bflush を呼び出す
   * 遅延書き込みバッファをほったらかしておくと、電源断などで不整合が生じる (要ジャーナリング?)

 * breada
    * design 本に書かれてる擬似コードと大体同じアルゴリズムで実装されている
     * 6th edtion の実装も大体同じ
    * 一個目の I/Oを発行、二個目のI/Oは B_ASYNC、一個目の I/O を sleep して待つ
    * ブロックデバイスから割り込みコンテキストで wakeup が実行されたらバッファを呼び出し元に返す

    /*
     * Wait for I/O completion on the buffer; return errors
     * to the user.
     */
    iowait(bp)
    struct buf *bp;
    {
    	register struct buf *rbp;

    	rbp = bp;
    	spl6();
    	while ((rbp->b_flags&B_DONE)==0)
    		sleep(rbp, PRIBIO);
    	spl0();
    	geterror(rbp);
    }

これらを区分すると ↓ の感じ。遅延(delayed) と 非同期(async) 意味分けに注意

    brelse  I/O 発行無し
    bdwrite I/O 発行無し、遅延
    bawrite I/O 発行、非同期
    bwrite  I/O 発行、同期

